[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Chiral_Phonons",
    "section": "",
    "text": "Introducción\nEn este libro se muestran los cálculos realizados por los estudiante Diego Bautista Avilés y Frida Fernanda García Lopez en colaboración con el Dr. José Eduardo Barrios Vargas y el Dr. Luis E. F. Foa Torre.\nPara el trabajo aquí realizado se agradece el apoyo a CONAHCYT por medio de una beca de proyecto CONAHCYT frontera."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "CadenasQuirales.html",
    "href": "CadenasQuirales.html",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "",
    "text": "2 Cálculos para la simetría \\(C_{2}\\)\nDebajo se muestra un bloque de código donde se define una función que construye y diagonaliza la matriz dinámica para una cadena con simetría \\(C_{2}\\), y que además obtiene la polarización de los modos vibracionales.\nFinalmente, se muestra la gráfica de bandas para la cadena \\(C_{2}\\):\nDebajo se muestra un bloque de código donde se define una función que construye y diagonaliza la matriz dinámica para una cadena con simetría \\(C_{2}\\), y que además obtiene la polarización de los modos vibracionales.\nFinalmente, se muestra la gráfica de bandas para la cadena $C_{3}:\nDebajo se muestra un bloque de código donde se define una función que construye y diagonaliza la matriz dinámica para una cadena con simetría \\(C_{2}\\), y que además obtiene la polarización de los modos vibracionales.\nFinalmente, se muestra la gráfica de bandas para la cadena $C_{4}:"
  },
  {
    "objectID": "CadenasQuirales.html#tensor-de-constantes-de-red-para-una-cadena-quiral",
    "href": "CadenasQuirales.html#tensor-de-constantes-de-red-para-una-cadena-quiral",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "1.1 Tensor de constantes de red para una cadena quiral",
    "text": "1.1 Tensor de constantes de red para una cadena quiral\nLos tensores de constante de red para estos sistemas se calculan siguiendo la técnica expuesta por Saito en su libro Physical Properties of Carbon Nanotubes, la cual consiste en transformar el tensor de esfuerzos en su representación diagonal por matrices de rotación cuyos ángulos son obtenidos de las posiciones relativas entre dos átomos del sistema. Para las cadenas modeladas a continuación, se supuso que los enlaces de interacción entre los átomos formaban ángulos de \\(\\varphi = \\pi/3\\) respecto a los planos perpendiculares al eje de traslación. Asimismo, vistos desde arriba los tres sitios tenían ángulos de \\(\\theta = 2 \\pi / n\\) entre ellos donde \\(n\\) es el entero que define la simetría \\(C_{n}\\).\nSe asumió que todos los átomos de la cadena (4 como máximo para el caso de \\(C_{4}\\)) tenían la misma masa. Asimismo, se asumió que en todos los casos el tensor de constante de red en su representación diagonal se escribía como sigue: \\[K_{x} = \\begin{pmatrix}K_{L} & 0 & 0 \\\\\n0 & K_{T1} & 0 \\\\\n0 & 0 & K_{T2}\\end{pmatrix},\\] donde \\(K_{L} = 1\\), \\(K_{T1} = 0.05\\) y \\(K_{T2} = 0.25\\).\n\n#Constantes\nm1 = 1\nm2 = 1\nm3 = 1\nm4 = 1\nc = 1\n\n\n#Matriz de resortes a lo largo de x.\nKL = 1\nKT1 = 0.05\nKT2 = 0.25\n\nKx = array([[KL,0,0],\n              [0,KT1,0],\n              [0,0,KT2]],dtype=complex)\n\nSe definió una rotación en torno al eje y como \\[T(\\varphi) = \\begin{pmatrix} \\cos (\\varphi) & 0 & \\sin (\\varphi) \\\\\n0 & 1 & 0 \\\\\n- \\sin (\\varphi) & 0 & \\cos(\\varphi)\\end{pmatrix}.\\] De esta forma, la constante de fuerza \\[K_{x2} = T(\\varphi) K_{x} T(- \\varphi)\\] tiene un angulo de \\(\\varphi\\) respecto al plano x - y. Por otra parte, se definió la matriz de rotación respecto al eje - z como \\[U(\\theta) = \\begin{pmatrix} \\cos (\\theta) & - \\sin (\\theta) & 0 \\\\\n- \\sin (\\theta) & \\cos (\\theta) & 0 \\\\\n0 & 0 & 1\\end{pmatrix}.\\] De esta forma, si \\(\\theta\\) era el ángulo entre dos sitios, podía definirse la constante de red entre dichos sitios como \\[K = U(\\theta)K_{x2}U(-\\theta).\\]\n\n#Rotación de φ respecto al plano x - y.\nφxy = pi/3\n\ndef T(φ):\n  return array([[cos(φ) ,0.  ,sin(φ)],\n                [0.     ,1.  ,0],\n                [-sin(φ),0.  ,cos(φ)]])\n\n\n#Rotación respecto al eje z.\ndef U(θ):\n  return array([[cos(θ),-sin(θ),0],\n              [sin(θ),cos(θ),0],\n              [       0,      0,1]] )\n\n\n#Matriz de resortes a lo largo de x.\nKL = 1\nKT1 = 0.05\nKT2 = 0.25\n\nKx = array([[KL,0,0],\n              [0,KT1,0],\n              [0,0,KT2]],dtype=complex)"
  },
  {
    "objectID": "CadenasQuirales.html#definición-de-la-matriz-dinámica",
    "href": "CadenasQuirales.html#definición-de-la-matriz-dinámica",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "1.2 Definición de la matriz dinámica",
    "text": "1.2 Definición de la matriz dinámica\nEn general, los elementos de la matriz dinámica tenían la forma \\[D_{ij} = - \\frac{K_{ij}}{\\sqrt{m_{i}m_{j}}}\\] para elementos fuera de la diagonal y \\[K_{ii} = \\frac{\\sum_{i\\neq j}Kij}{m_{i}}\\] para elementos fuera de la diagonal. En este último término la suma es solo sobre los primeros vecinos del elemento i. Asimismo, en caso de que la interacción fuera con un elemento fuera de la celda unitaria, se añadía la fase correspondiente."
  },
  {
    "objectID": "CadenasQuirales.html#definición-del-operador-de-polarización",
    "href": "CadenasQuirales.html#definición-del-operador-de-polarización",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "1.3 Definición del operador de polarización",
    "text": "1.3 Definición del operador de polarización\nLa quiralidad de los fonones se determina a partir de un valor no nulo de la polarización de fonón. Esta se obtiene apartir del valor esperado del operador de polarización. Este operador corresponde a la proyección sobre una base con movimiento circular bien definido. Para un sólo átomo, esta base es \\[| R \\rangle = \\frac{1}{\\sqrt{2}}(1,i)^{T}; | L \\rangle = \\frac{1}{\\sqrt{2}}(1,-i)^{T}.\\] Explícitamente, el operador de Polarización está dado por \\[\\hat{S}_{z} = \\sum_{\\alpha = 1}^{n} \\left(|R_{\\alpha}\\rangle \\langle R_{\\alpha}| -  |L_{\\alpha}\\rangle \\langle L_{\\alpha}|\\right).\\] La suma se hace sobre todos los sitios del sistema. Debajo, se muestran bloques de código donde se define un operador de pseudomomento para una cadena con \\(n\\) átomos, así como una función que calcula el valor esperado de un operador.\n\ndef OperadorPseudomomento(n):\n\n  Sz = array([[0,-1J,0],\n              [1J,0,0],\n              [0,0,0]],dtype=complex)\n\n  return np.kron(np.eye(n,dtype=complex),Sz)\n\ndef expectedval(vec,S):\n    return dot(np.conj(vec).T,dot(S,vec)).real"
  },
  {
    "objectID": "nanocinta.html",
    "href": "nanocinta.html",
    "title": "2  Descripción de una nanocinta de grafeno",
    "section": "",
    "text": "Este código busca describir los modos vibracionales de un ribbon de grafeno. Para ello, se usa la paquetería ASE para importar un objeto con las posiciones y masas del ribbon. Este ribbon se construye especificando los índices (n,m) que definen la celda unitaria. En el código, se implementa una función que calcula los primeros vecinos del ribbon, especificando si son intracelda o extracelda. Esto permite hacer una gráfica del objeto.\nPosteriormente, se define una función que consigue obtener el tensor de constante de red entre cualesquiera dos sitios. Para ello, se parte del tensor de esfuerzos de los carbonos en grafeno y se aplican las transformaciones pertinentes.\n\n#Primero, se importan las paqueterías a usar. \n\nfrom pylab import *\nfrom ase.build import graphene_nanoribbon\nimport plotly.graph_objects as go\nfrom numpy import linalg as LA\nfrom scipy.linalg import ishermitian\n\n\n#Se construye el objeto de nanotubo, se obtienen las posiciones y masas de cada átomo. \n\ncnt1     = graphene_nanoribbon(10,2, type='zigzag')\nr        = cnt1.get_positions()\nX,Y,Z    = cnt1.get_positions().T\nnsites   = len(X)\na1,a2,a3 = array(cnt1.get_cell())\n\ncluz = 3e10 #cm/\nmasas = cnt1.get_masses()\nmasas = 1.66e-27*masas\n\nprint(f\"nsites = {nsites}\")\nprint(f\"    a1 = {a1}\")\nprint(f\"    a2 = {a2}\")\nprint(f\"    a3 = {a3}\")\n\nnsites = 40\n    a1 = [0. 0. 0.]\n    a2 = [0. 0. 0.]\n    a3 = [0.         0.         4.91902429]\n\n\n\n#Debajo, se definen las funcioens que buscan los primeros vecinos. Además, se define la función que permite graficar el ribbon.\n\ndef findnn(X,Y,Z):\n  nn = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos],Y[todos],Z[todos]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas<1.44 # distancia en Ang para encontrar los vecinos\n\n      nn[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn\n\ndef findnn_minus(X,Y,Z):\n  nn_minus_a3 = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos]+a3[0],Y[todos]+a3[1],Z[todos]+a3[2]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas<1.44 # distancia en Ang para encontrar los vecinos\n\n      nn_minus_a3[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn_minus_a3\n\ndef findnn_plus(X,Y,Z):\n  nn_plus_a3 = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos]-a3[0],Y[todos]-a3[1],Z[todos]-a3[2]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas<1.44 # distancia en Ang para encontrar los vecinos\n\n      nn_plus_a3[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn_plus_a3\n\ndef GetDATAplot(X,Y,Z,nn,nn_minus_a3,nn_plus_a3):\n  DATA = [go.Scatter3d(x=X, y=Y, z=Z,mode='markers',showlegend=False)]\n\n  for key in nn: # para cada sitio\n      for n in nn[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key],X[n]], y=[Y[key],Y[n]], z=[Z[key],Z[n]],mode='lines',line=dict(color='blue'),showlegend=False))\n\n  for key in nn_minus_a3: # para cada sitio\n      for n in nn_minus_a3[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key]+a3[0],X[n]], y=[Y[key]+a3[1],Y[n]], z=[Z[key]+a3[2],Z[n]],mode='lines',line=dict(color='red'),showlegend=False) )\n\n  for key in nn_plus_a3: # para cada sitio\n      for n in nn_plus_a3[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key]-a3[0],X[n]], y=[Y[key]-a3[1],Y[n]], z=[Z[key]-a3[2],Z[n]],mode='lines',line=dict(color='red'),showlegend=False) )\n\n  annos = []\n  # for n in range(len(X)):\n  for n in range(len(X)):\n    anno = dict(x=X[n],\n                y=Y[n],\n                z=Z[n],\n                text=str(n),\n                showarrow=False,\n                arrowhead=0,\n                font=dict(color='black'),\n                ax=0,\n                ay=0,\n                bgcolor=\"white\",\n                opacity=0.2)\n\n    annos.append(anno)\n\n  return DATA,annos\n\n\n#Los primeros vecinos se almacenan en un diccionario. \n\nnn = findnn(X,Y,Z)\nnn_minus_a3 = findnn_minus(X,Y,Z)\nnn_plus_a3  = findnn_plus(X,Y,Z)\n\n\n#Se construye la imagen del ribbon. \n\nDATA,annos = GetDATAplot(X,Y,Z,nn,nn_minus_a3,nn_plus_a3)\nfig = go.Figure(data=DATA)\nfig.update_layout(scene=dict(annotations=annos))\nfig.show()\n\n\n                                                \n\n\n\n#Se define la función que calcula el tensor de constante de red para cualesquiera dos puntos. \n\nKL1 = 365.0 #N/m\nKT1 = 245.0 #N/m\nKZ1 = 98.2 #N/m\n\nKrib = array([[KL1,0,0],\n            [0,KZ1,0],\n            [0,0,KT1]],dtype=complex)\n\ndef KGeneral(r1,r2):\n  \n  x1,z1 = r1[0],r1[2]\n  x2,z2 = r2[0],r2[2]\n\n  x = x2 - x1\n  z = z2 - z1\n\n  θ = arctan(z/x)\n\n  T = array([[cos(θ) ,0.  ,-sin(θ)],\n                [0.     ,1.  ,0],\n                [sin(θ),0.  ,cos(θ)]],dtype = complex)\n\n  return dot(T,dot(Krib,inv(T)))\n\n\n#Ahora, se calcula una función que construye la matriz dinámica para cada punto en el espacio k, y obtiene las eigenfrecuencias y pseudomomento asociado. \n\n#Para ello, se definen una función que calcula la polarización de fonón y otra que calcula el valor esperado. \n\ndef OperadorPseudomomento(n):\n\n  Sz = array([[0,-1J,0],\n              [1J,0,0],\n              [0,0,0]],dtype=complex)\n\n  return np.kron(np.eye(n,dtype=complex),Sz)\n\nS = OperadorPseudomomento(nsites)\n\ndef expectedval(vec,S):\n    return dot(np.conj(vec).T,dot(S,vec)).real\n\ndef Eigenfrequencies(kvec):\n  MatrizDinamica = {}\n  MatInt = array(range(nsites*nsites)).reshape(nsites,nsites)\n\n  for i in range(len(X)):\n\n    ri = [X[i],Y[i],Z[i]]\n\n    Kdiagi = np.zeros((3,3))\n\n    for n in nn[i]:\n      rn = [X[n],Y[n],Z[n]]\n      Kdiagi = Kdiagi + KGeneral(ri,rn)\n    for n in nn_plus_a3[i]:\n      rn = [X[n],Y[n],Z[n]] + a3\n      Kdiagi = Kdiagi + KGeneral(ri,rn)\n    for n in nn_minus_a3[i]:\n      rn = [X[n],Y[n],Z[n]] - a3\n      Kdiagi = Kdiagi + KGeneral(ri,rn)\n\n    MatrizDinamica[(nsites)*i + i] = Kdiagi/masas[i]\n\n    for j in range(i+1,len(X)):\n      rj = [X[j],Y[j],Z[j]]\n      if j in nn[i]:\n        K = -1*KGeneral(ri,rj)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*i + j] = -1*KGeneral(ri,rj)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*j + i] = K\n      elif j in nn_plus_a3[i]:\n        K = -1*KGeneral(ri,rj + a3)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*i + j] = K*exp(1J*kvec)\n        MatrizDinamica[(nsites)*j + i] = K*exp(-1J*kvec)\n      elif j in nn_minus_a3[i]:\n        K = -1*KGeneral(ri,rj - a3)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*i + j] = K*exp(-1J*kvec)\n        MatrizDinamica[(nsites)*j + i] = K*exp(1J*kvec)\n      else:\n          MatrizDinamica[(nsites)*i + j] = np.zeros((3,3))\n          MatrizDinamica[(nsites)*j + i] = np.zeros((3,3))\n\n  MatrizDinamica = dict(sorted(MatrizDinamica.items()))\n\n  Dm = [ [MatrizDinamica[i] for i in rw] for rw in MatInt ]\n  Dynamical = asarray(np.bmat(Dm))\n\n  ω2,eigvecs = eigh(Dynamical)\n\n  pseudomom = []\n\n\n  for i in range(len(ω2)):\n    eigvec = eigvecs[:,i]\n    pseudomom.append(expectedval(eigvec,S))\n\n\n  return sqrt(abs(ω2))/2/pi/cluz,pseudomom\n\n\n#Finalmente, se hace el cálculo de las bandas de frecuencia.\n\nKpoints = np.linspace(-pi,pi,500)\n\nKlabels = [r\"K/2\",r\"Γ\",r\"K/2\"]\nKticks = concatenate([[0],[250],[500]])\n\nBandas = []\nPseudomom = []\n\nKevaluate = (list( map(Eigenfrequencies,Kpoints) ))\n\nfor ω2,psmom in Kevaluate:\n  Bandas.append(ω2)\n  Pseudomom.append(psmom)\n\nBandas = array(Bandas)\nPseudomom = array(Pseudomom)\n\nnumK,nbands = shape(Bandas)\nkenum = arange(numK)\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbands):\n  grafica = ax.scatter(kenum,Bandas.T[j],c = Pseudomom.T[j],cmap = \"coolwarm\",vmax = 1, vmin = -1,s = 5)\nfig.colorbar(grafica)\nax.set_xticks(Kticks)\n#ax.set_ylim(1,100)\nax.set_xticklabels(Klabels,fontsize = 20);"
  },
  {
    "objectID": "CCMC3.html",
    "href": "CCMC3.html",
    "title": "4  Cálculo de CCM para una cadena quiral C3",
    "section": "",
    "text": "4.1 Cálculo de CCM de la estructura\nPara calcular el CCM de la estructura se sigue la definición del capítulo pasado. Sin embargo, para hacer este cálculo sólo se consideran reflexiones por planos que contengan al eje z. Esto pues sólo nos interesa la quiralidad respecto a este eje. Aún así, se define una rotación respecto al plano x - y que será utilizada más adelante en el cálculo de la matriz dinámica.\n#Rotación de φ respecto al plano x - y.\ndef T(φ):\n  return array([[cos(φ) ,0.  ,sin(φ)],\n                [0.     ,1.  ,0],\n                [-sin(φ),0.  ,cos(φ)]])\n\n                #Rotación respecto al eje z.\ndef U(θ):\n  return array([[cos(θ),-sin(θ),0],\n              [sin(θ),cos(θ),0],\n              [       0,      0,1]] )\nTambién se definen la matriz identidad en 3D y una reflexión respecto al plano xz. Además, se define una funciín que transforma operadores. Esta función se usará para rotar el plano respecto al cual se realiza la rotación.\n#Matriz identidad.\nId = array([[1,0,0],\n            [0,1,0],\n            [0,0,1]] )\n\n#Reflexión respecto al plano x - z.\nσy = array([[-1,0,0],\n            [0,1,0],\n            [0,0,1]] )\n\ndef TensT(O,A):\n  \"\"\"Función que aplica transforma por un operador O a un tensor A.\"\"\"\n  return dot( inv(O), dot(A,O) )\nYa con todas las funciones a usar bien definidas, se hace el cálculo de la CCM De la estructura. Para ello, primero se calculan las coordenadas respecto al centro de masa.\n# Centro de masa\nRCM = (m1*r1 + m2*r2 + m3*r3)/(m1 + m2 + m3)\n\n# Coordenada Relativa 1\nqrcm1 = sqrt(m1)*(r1 - RCM)\n\n# Coordenada Relativa 2\nqrcm2 = sqrt(m2)*(r2 - RCM)\n\n# Coordenada Relativa 3\nqrcm3 = sqrt(m3)*(r3 - RCM)\n\n# Lista con las coordenadas relativas. \nQrcm = [qrcm1,qrcm2,qrcm3]\nQueremos calcular la CCM tal que el plano de inversión elegido maximize la superposición de la estructura con la estructura invertida. Para ello, se define una función que calcula el CCM de la estructura tomando una reflexión respecto a un plano de entrada.\ndef CCMS(σ):\n    num = 0\n    den = 0\n    for q in Qrcm:\n        num = num + dot(q,dot(Id + σ,q))\n        den = den + dot(q,q)\n    return 1 - (num/(2*den))\nYa hecho esto, se calcula el CCM de la estructura. Notamos que para esta cadena el CCM es igual sin importar que plano de reflexión se use. Esto se ve en la gráfica mostrada debajo.\nθ = linspace(0,pi,300)\n\nσ = []\n\nfor ang in θ:\n    σ.append(TensT(U(ang),σy))\nσ = array(σ)\n\nCCM_estructura = []\n\nfor ref in σ:\n    CCM_estructura.append(CCMS(ref))\n\nprint(\"La CCM de la estructura es\", str(np.min(CCM_estructura)))\n\nLa CCM de la estructura es 0.16666666666666674\nLabels = [r\"0\",r\"π/2\",r\"π\"]\nTicks = concatenate([[0],[pi/2],[pi]])\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(6,4.5))\nax.plot(θ,CCM_estructura)\nax.set_xticks(Ticks)\nax.set_ylim([0,1])\nax.set_xticklabels(Labels,fontsize = 20);\nax.set_ylabel(\"CCM\",fontsize = 20)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Cálculo de CCM para una cadena quiral C3</span>"
    ]
  },
  {
    "objectID": "CCMC3.html#cálculo-de-ccm-de-la-estructura",
    "href": "CCMC3.html#cálculo-de-ccm-de-la-estructura",
    "title": "4  Cálculo de CCM para una cadena quiral C3",
    "section": "4.1 Cálculo de CCM de la estructura",
    "text": "4.1 Cálculo de CCM de la estructura\nPara calcular el CCM de la estructura se sigue la definición del capítulo pasado. Sin embargo, para hacer este cálculo sólo se consideran reflexiones por planos que contengan al eje z. Esto pues sólo nos interesa la quiralidad respecto a este eje. Aún así, se define una rotación respecto al plano x - y que será utilizada más adelante en el cálculo de la matriz dinámica.\n\nr2 - dot(U(2*pi/3),r1)\n\narray([0.        , 0.        , 1.73205081])\n\n\nTambién se definen la matriz identidad en 3D y una reflexión respecto al plano xz. Además, se define una funciín que transforma operadores. Esta función se usará para rotar el plano respecto al cual se realiza la rotación.\n\n#Matriz identidad.\nId = array([[1,0,0],\n            [0,1,0],\n            [0,0,1]] )\n\n#Reflexión respecto al plano x - z.\nσy = array([[-1,0,0],\n            [0,1,0],\n            [0,0,1]] )\n\ndef TensT(O,A):\n  \"\"\"Función que aplica transforma por un operador O a un tensor A.\"\"\"\n  return dot( inv(O), dot(A,O) )\n\nYa con todas las funciones a usar bien definidas, se hace el cálculo de la CCM De la estructura. Para ello, primero se calculan las coordenadas respecto al centro de masa.\n\n# Centro de masa\nRCM = (m1*r1 + m2*r2 + m3*r3)/(m1 + m2 + m3)\n\n# Coordenada Relativa 1\nqrcm1 = sqrt(m1)*(r1 - RCM)\n\n# Coordenada Relativa 2\nqrcm2 = sqrt(m2)*(r2 - RCM)\n\n# Coordenada Relativa 3\nqrcm3 = sqrt(m3)*(r3 - RCM)\n\n# Lista con las coordenadas relativas. \nQrcm = [qrcm1,qrcm2,qrcm3]\n\nQueremos calcular la CCM tal que el plano de inversión elegido maximize la superposición de la estructura con la estructura invertida. Para ello, se define una función que calcula el CCM de la estructura tomando una reflexión respecto a un plano de entrada.\n\ndef CCMS(σ):\n    num = 0\n    den = 0\n    for q in Qrcm:\n        num = num + dot(q,dot(Id + σ,q))\n        den = den + dot(q,q)\n    return 1 - (num/(2*den))\n\nYa hecho esto, se calcula el CCM de la estructura. Notamos que para esta cadena el CCM es igual sin importar que plano de reflexión se use. Esto se ve en la gráfica mostrada debajo.\n\nθ = linspace(0,pi,300)\n\nσ = []\n\nfor ang in θ:\n    σ.append(TensT(U(ang),σy))\nσ = array(σ)\n\nCCM_estructura = []\n\nfor ref in σ:\n    CCM_estructura.append(CCMS(ref))\n\nprint(\"La CCM de la estructura es\", str(np.min(CCM_estructura)))\n\nLa CCM de la estructura es 0.16666666666666663\n\n\n\nLabels = [r\"0\",r\"π/2\",r\"π\"]\nTicks = concatenate([[0],[pi/2],[pi]])\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(6,4.5))\nax.plot(θ,CCM_estructura)\nax.set_xticks(Ticks)\nax.set_ylim([0,1])\nax.set_xticklabels(Labels,fontsize = 20);\nax.set_ylabel(\"CCM\",fontsize = 20)\nplt.show()"
  },
  {
    "objectID": "GrafenoCCM.html#medida-de-quiralidad-continua",
    "href": "GrafenoCCM.html#medida-de-quiralidad-continua",
    "title": "3  Cálculos de Medida de Quiralidad Continua",
    "section": "3.1 Medida de Quiralidad Continua",
    "text": "3.1 Medida de Quiralidad Continua\nLa quiralidad se define como el rompimiento de toda posible simetría de espejo. La propuesta detrás de la técnica de CCM es la medición de simetría continua, la cual compara la superposición de un objeto con el objeto más similar que contenga la simetría de interés. En el caso de quiralidad, esto implica medir la superosición entre un objeto y el objeto aquiral más similar. Específicamente, si \\(|Q\\rangle\\) es un objeto representado por un vector en un espacio vectorial, el objeto aquiral más cercano es \\[|Q'\\rangle = \\frac{1}{2}(\\mathbb{1} + \\sigma)|Q\\rangle,\\] donde \\(\\sigma\\) es la simetría de espejo tal que \\(\\langle Q|Q'\\rangle\\) sea máxima. Con esto en mente, la cantidad normalizada \\(\\langle Q|Q'\\rangle / \\langle Q|Q\\rangle\\) siempre será uno para una estructura aquiral y se aproxima a cero para una estructura quiral. DIcho eso, podemos expresar la Medida de Quiralidad continua como \\[\\text{CCM}(Q) = 1 - \\frac{\\langle Q|Q'\\rangle}{\\langle Q|Q\\rangle}.\\] Vemos que CCM va de 0 a 1, donde los objetos aquirales tienen CCM nula, mientras que los objetos quirales tienen CCM alta.\nPara medir la quiralidad de una estructura, \\(|Q\\rangle\\) toma el valor de las coordenadas relativas al centro de masa pesadas por el centro de masa: \\(|q_{i}\\rangle = \\sqrt{m_{i}}(x_{i},y_{i},z_{i})^{\\text{T}}\\). Entonces, la CCM asociada a la estructura es \\[\\text{CCM}(Q) = 1 - \\frac{\\sum_{i = 1}^{N} \\langle q_{i}|\\mathbb{1} + \\sigma | q_{i}\\rangle}{2\\sum_{i = 1}^{N} \\langle q_{i}|q_{i}\\rangle}.\\]"
  },
  {
    "objectID": "GrafenoCCM.html#cálculo-de-la-ccm-para-una-celda-de-grafeno.",
    "href": "GrafenoCCM.html#cálculo-de-la-ccm-para-una-celda-de-grafeno.",
    "title": "3  Cálculos de Medida de Quiralidad Continua",
    "section": "3.2 Cálculo de la CCM para una celda de grafeno.",
    "text": "3.2 Cálculo de la CCM para una celda de grafeno.\nDebajo, hacemos el cálculo de la CCM para una estructura de grafeno dopado, esto es, una estructura donde uno de los Carbono - 12 en cada celda es sustituido por un Carbono 13.\nPrimero, se importan las librerías y se definen cantidades que serán de utilidad más adelante.\n\nfrom pylab import *\n\n\n# Constante de red en amstong\naCC = 0.142 \n\n# Separación entre planos en dirección z\n# no relevante en este caso \n\n#Vectores base\na1 = sqrt(3)*aCC*array([sqrt(3)/2, 1/2]) \na2 = sqrt(3)*aCC*array([sqrt(3)/2,-1/2])\n\n#Masa de cada sitio\nm1 =  2E-26\nm2 = 2.158E-26\nm2 = m1\n\n#Velocidad de la luz en cm/s\ncluz = 2.99792458E10\n\nLos sitios de los orbitales se escriben debajo en términos de los vectores de red. Además, se calculan las coordenadas del centro de masa y las coordenadas relativas.\n\n#Coordendadas de los sitios\ns1 = (a1 + a2)/3\ns2 = 2*(a1 + a2)/2\n\n#Coordenadas centro de masa\nRCM = (m1*s1 + m2*s2)/(m1 + m2)\n\n# Coordenada Relativa 1\nqrcm1 = sqrt(m1)*(s1 - RCM)\n\n#Coordenada Relativa 2\nqrcm2 = sqrt(m2)*(s2 - RCM)\n\nQrcm = [qrcm1,qrcm2]\n\nPara evaluar la reflexión que maximizaba la aquiralidad de la estructura, se partió de una reflexión respecto al eje \\(y\\) que fue rotada por varios ángulos hasta encontrar el apropiado. Para ello, primero se definen la reflexión y un operador de rotación. Asimismo, se define una función que aplica la rotación a un operador arbitrario.\n\n#Matriz identidad.\nId = array([[1,0],\n              [0,1]] )\n\n#Reflexión respecto al eje y.\nσy = array([[-1,0],\n              [0,1]] )\n\ndef Rot(θ):\n\n  \"\"\"Función que regresa una matriz de rotación por un ángulo θ.\"\"\"\n\n  return array([[cos(θ),sin(θ)],\n              [-sin(θ),cos(θ)]] )\n\ndef TensT(θ,A):\n  \"\"\"Función que aplica una rotación por θ a un tensor A.\"\"\"\n  return dot( inv(Rot(θ)), dot(A,Rot(θ)) )\n\nCon esto, se define la función que hace el cálculo del CCM de la estructura.\n\ndef CCMS(σ):\n    num = 0\n    den = 0\n    for q in Qrcm:\n        num = num + dot(q,dot(Id + σ,q))\n        den = den + dot(q,q)\n    return 1 - (num/(2*den))\n\nDebido a que hubo una ruptura de simetría respecto al eje y, es de esperarse que la reflexión \\(\\sigma_{y}\\) definida arriba sea la que maximice el CCM. Esto se comprueba debajo, pues el CCM máximo es aquel donde la reflexión no es alterada.\n\nθ = linspace(0,pi,300)\n\nσ = []\n\nfor ang in θ:\n    σ.append(TensT(ang,σy))\nσ = array(σ)\n\nCCM_estructura = []\n\nfor ref in σ:\n    CCM_estructura.append(CCMS(ref))\n\nCCM_estructura = array(CCM_estructura)\n\nLabels = [r\"0\",r\"π/2\",r\"π\"]\nTicks = concatenate([[0],[pi/2],[pi]])\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(6,4.5))\nax.plot(θ,CCM_estructura)\nax.set_xticks(Ticks)\nax.set_xticklabels(Labels,fontsize = 20);\nax.set_ylabel(\"CCM\",fontsize = 20)\nplt.show()"
  },
  {
    "objectID": "GrafenoCCM.html#cálculo-de-ccm-de-los-modos",
    "href": "GrafenoCCM.html#cálculo-de-ccm-de-los-modos",
    "title": "3  Cálculos de Medida de Quiralidad Continua",
    "section": "3.3 Cálculo de CCM de los modos",
    "text": "3.3 Cálculo de CCM de los modos\nUna vez determinado que \\(\\sigma_{y}\\) corresponde a la reflexión que maximizaba la quiralidad, se optó por usar esta reflexión para calcular el grado de quiralidad de los modos normales. A modo de comparación, se mostrarán los cálculos realizados por Lifa Zhang.\nCon este fin, primero se definen los vectores de la red recíproca, así como varias funciones necesarias para los cálculos a realizar.\n\n# Se obtienen los vectores recíprocos.\nA   = array([a1,a2])\nB   = 2*pi*inv(A)\nb1,b2 = B.T\n\ndef GetkPath(kpoints,numNk):\n    \"\"\"\n    Función que determina los puntos en un camino en el espacio\n    recíproco que conecta los distintos puntos kpoints, dividiendo\n    el camino en numK divisiones.\n\n    Regresa las duplas de puntos k en el camino y los índices de\n    los puntos donde se encuentran los diferentes kpoints.\n    \"\"\"\n    numP = len(kpoints)\n    Dist = []\n    for k in range(numP-1):\n        veck = kpoints[k+1]-kpoints[k]\n        D    = sqrt( dot(veck,veck) )\n        Dist.append( D )\n    Dist = array(Dist)\n    Nk_p = array( [ int(numNk*DD/Dist.sum()) for DD in Dist ] )\n    # print(Nk_p)\n    if (Nk_p.sum()<numNk):\n        Nk_p[-1] = numNk - Nk_p[:-1].sum()\n    KX, KY= array([]),array([])\n    for k in range(numP-1):\n        KX = concatenate([KX,linspace(kpoints[k][0],kpoints[k+1][0],Nk_p[k])])\n        KY = concatenate([KY,linspace(kpoints[k][1],kpoints[k+1][1],Nk_p[k])])\n    return column_stack((KX,KY)),concatenate([[0],cumsum(Nk_p)])\n\n# Función que asigna una fase intercelda\n\ndef fase(k,n,m):\n  return exp(1J*dot(k,(n*a1 + m*a2)))\n\n# Operador de polarización de fonón\nSzA = array([[0,-1J,0,0],\n            [1J,0,0,0],\n            [0,0,0,0],\n            [0,0,0,0]],dtype=complex)\nSzB = array([[0,0,0,0],\n            [0,0,0,0],\n            [0,0,0,-1J],\n            [0,0,1J,0]],dtype=complex)\n\nSz = SzA + SzB\n\n# Función que calcula el valor esperado de un vector. \ndef expectedval(vec,S = Sz):\n    return vdot(vec,dot(S,vec)).real\n\nDebajo, se muestra una función que calcula los modos normales de vibración del grafeno. En esta función se obtienen tanto el valor de polarización de fonón (método de Lifa Zhang), como el valor de CCM. Para ello, antes se define una función que regresa el CCM.\n\nθ = linspace(0,pi,300)\n\ndef CCMMax(q):\n    max = 0\n\n\n    for ang in θ:\n        σ = TensT(ang,σy)\n        if abs(expectedval(q,Id + σ)) > max:\n            max = abs(expectedval(q,Id + σ))\n            M = expectedval(q,Id + σ)\n\n    return M\n\n\ndef Eigenfrequencies(k):\n\n  mA = 2E-26\n  mB = 2.158E-26\n\n  #Se define la matriz de fuerzas a primeros vecinos.\n  KL1 = 365.0 #N/m\n  KT1 = 245.0 #N/m\n\n  K1 = array([[KL1,0],\n              [0,KT1]],dtype=complex)\n\n  #Se obtienen las contribuciones a primeros vecinos.\n\n  C11 = K1\n\n  θ12 = 120*pi/180\n  C12 = TensT(θ12,K1)\n\n  θ13 = 240*pi/180\n  C13 = TensT(θ13,K1)\n\n  DAA1 = C11+C12+C13\n  DAB1 = -1 * ( C11 + C12*fase(k,0,-1)+C13*fase(k,-1,0) )\n  DBA1 = DAB1.conj().T\n  DBB1 = DAA1\n\n  #Se obtienen las contribuciones a segundos vecinos.´\n  DicMat   = { 0: 1/sqrt(m1*m1)*(DAA1),\n               1: 1/sqrt(m1*m2)*(DAB1),\n               2: 1/sqrt(m1*m2)*(DBA1),\n               3: 1/sqrt(m2*m2)*(DBB1)}\n\n  Dinteger = array([[0,1],\n                    [2,3]])\n\n  Dm = [ [DicMat[i] for i in rw] for rw in Dinteger ]\n  Dynamical = asarray(np.bmat(Dm))\n\n  ω2,eigvecs = eigh(Dynamical)\n\n  pseudomom = []\n\n  for i in range(len(ω2)):\n    eigvec = eigvecs[:,i]\n    pseudomom.append(expectedval(eigvec,S = Sz))\n\n  CCM = []\n    \n  for i in range(len(ω2)):\n    eigvec = eigvecs[:,i]\n    q1 = sqrt(m1) * eigvec[0:2]\n    q2 = sqrt(m2) * eigvec[2:]\n\n    Q = [q1,q2]\n\n    num = 0\n    den = 0\n\n    for q in Q:\n        num = num + CCMMax(q)\n        den = den + vdot(q,q).real\n\n    CCM.append(1 - (num/(2*den)))\n\n\n  return sqrt(abs(ω2))/2/pi/cluz,pseudomom,CCM\n\n\nΓ = dot( [  0,  0], B.T)\nK = dot( [1/3,2/3], B.T)\nM = dot( [1/2,1/2], B.T)\n# alat\n\nKpath  = array([K,Γ,K])\nKlabels = [r\"K\",r\"$\\Gamma$\",r\"K\"]\nKpoints,Kticks = GetkPath(Kpath,1000)\n\nDATA = array(list( map(Eigenfrequencies,Kpoints) ))\n\nfrec = DATA[:,0,:]\npseudomom = DATA[:,1,:]\nCCM = DATA[:,2,:]\n\nSe realizan las gráficas.\n\nnbands = 4\nkenum = arange(len(frec))\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbands):\n    grafica = ax.scatter(kenum,frec.T[j],c = pseudomom.T[j],cmap = \"coolwarm\",vmax = 1, vmin = -1,s = 5)\nax.set_xticks(Kticks)\nax.set_xticklabels(Klabels,fontsize = 20);\nfig.colorbar(grafica)\n\n<matplotlib.colorbar.Colorbar at 0x7f05683f7170>\n\n\n\n\n\n\nnbands = 4\nkenum = arange(len(frec))\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbands):\n    grafica = ax.scatter(kenum,frec.T[j],c = CCM.T[j],cmap = \"Reds\",vmax = 1, vmin = 0,s = 5)\nax.set_xticks(Kticks)\nax.set_xticklabels(Klabels,fontsize = 20);\nfig.colorbar(grafica)\n\n<matplotlib.colorbar.Colorbar at 0x7f05683f74d0>\n\n\n\n\n\n\nnp.max(CCM)\n\n0.49999999999999956"
  },
  {
    "objectID": "CCMC3.html#cálculos-para-la-simetría-c_3",
    "href": "CCMC3.html#cálculos-para-la-simetría-c_3",
    "title": "4  Cálculo de CCM para una cadena quiral C3",
    "section": "4.2 Cálculos para la simetría \\(C_{3}\\)",
    "text": "4.2 Cálculos para la simetría \\(C_{3}\\)\nDebajo se muestra un bloque de código donde se define una función que construye y diagonaliza la matriz dinámica para una cadena con simetría \\(C_{2}\\), y que además obtiene la polarización de los modos vibracionales. \\[\n\\newcommand{\\de}{\\text{d}}\n\\begin{align*}\n    \\frac{\\de y}{\\de t} & = 1.75\\left[-\\sin(t) \\sen(t) + \\cos(t)(1 + \\cos(t)) \\right] \\\\\n    & = 1.75\\left[-\\sin^{2}(t) + \\cos(t) + \\cos^{2}(t)\\right] \\\\\n    & = 1.75 \\left[(\\cos^{2}(t) - 1) + \\cos(t) + \\cos^{2}(t)\\right] \\\\\n    & = 1.75\\left[2\\cos^{2}(t) + \\cos(t) - 1 \\right] \\\\\n    & = 1.75(\\cos(t) + 1)(2\\cos(t) - 1)\n\\end{align*}\n\\]\n\ndef expectedval(vec,S):\n    return dot(np.conj(vec).T,dot(S,vec)).real\n\nθ = linspace(0,pi,300)\n\ndef CCMMax(q):\n    max = 0\n    for ang in θ:\n        σ = TensT(U(ang),σy)\n        if abs(expectedval(q,Id + σ)) > max:\n            max = abs(expectedval(q,Id + σ))\n            M = expectedval(q,Id + σ)\n    return M\n\n\ndef EigenfrequenciesC3(k):\n\n  \"\"\"Función que regresa las eigenfrecuencias para un vector recíproco kz dado.\"\"\"\n\n  #Se define el tensor de esfuerzos de todo el sistema.\n\n  #Matriz con constante de fuerza considerando una rotación respecto al plano x - y.\n  φxy = pi/3\n  Kx2 = dot(T(φxy),dot(Kx,T(-φxy)))\n\n  #Matrices de fuerza para cada uno de los vectores en la red.\n  K23 = dot(U(pi),dot(Kx2,U(-pi)))     #Calculada tomando 2 como origen.\n  K12 = dot(U(pi/3),dot(Kx2,U(-pi/3))) #Calculada tomando 1 como origen.\n  K13 = dot(U(-pi/3),dot(Kx2,U(pi/3))) #Calculado tomando 3 como origen.\n\n  DicMat   = { 0: (K12 + K13)/m1,\n               1: -K12/sqrt(m1*m2),\n               2: -K13/sqrt(m1*m3)*exp(-1J*k*c),\n               3: -K12/sqrt(m1*m2),\n               4: (K23+K12)/m2,\n               5: -K23/sqrt(m2*m3),\n               6: -K13/sqrt(m1*m3)*exp(1J*k*c),\n               7: -K23/sqrt(m2*m3),\n               8: (K23 + K13)/m3 }\n\n  Dinteger = array([[0,1,2],\n                    [3,4,5],\n                    [6,7,8]])\n\n  Dm = [ [DicMat[i] for i in rw] for rw in Dinteger ]\n  Dynamical = asarray(np.bmat(Dm))\n\n  ω2,eigvecs = eigh(Dynamical)\n\n  #Se definen los operadores de Pseudomomento.\n\n  CCM = []\n    \n  for i in range(len(ω2)):\n    eigvec = eigvecs[:,i]\n    q1 = sqrt(m1) * eigvec[0:3]\n    q2 = sqrt(m2) * eigvec[3:6]\n    q3 = sqrt(m3) * eigvec[6:]\n\n    Q = [q1,q2]\n\n    num = 0\n    den = 0\n\n    for q in Q:\n        num = num + CCMMax(q)\n        den = den + vdot(q,q).real\n\n    CCM.append(1 - (num/(2*den)))\n\n  return sqrt(abs(ω2))/2/pi,CCM\n\nFinalmente, se muestra la gráfica de bandas para la cadena \\(C_{3}\\):\n\nKpoints = np.linspace(-pi/c,pi/c,500)\n\nKlabels = [r\"K/2\",r\"Γ\",r\"K/2\"]\nKticks = concatenate([[0],[250],[500]])\n\nBandasC3 = []\nPseudomomC3 = []\n\nKevaluateC3 = (list( map(EigenfrequenciesC3,Kpoints) ))\n\nfor ω2,psmom in KevaluateC3:\n  BandasC3.append(ω2)\n  PseudomomC3.append(psmom)\n\nBandasC3 = array(BandasC3)\nPseudomomC3 = array(PseudomomC3)\n\nnumKC3,nbandsC3 = shape(BandasC3)\nkenumC3 = arange(numKC3)\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbandsC3):\n  graficaC3 = ax.scatter(kenumC3,BandasC3.T[j],c = PseudomomC3.T[j],cmap = \"Reds\",vmax = 1, vmin = 0,s = 5)\nfig.colorbar(graficaC3)\nax.set_xticks(Kticks)\nax.set_xticklabels(Klabels,fontsize = 20);"
  },
  {
    "objectID": "CCMC3.html#cálculos-del-ccm-de-los-modos-vibracionales",
    "href": "CCMC3.html#cálculos-del-ccm-de-los-modos-vibracionales",
    "title": "4  Cálculo de CCM para una cadena quiral C3",
    "section": "4.2 Cálculos del CCM de los modos vibracionales",
    "text": "4.2 Cálculos del CCM de los modos vibracionales\nAhora calculamos el CCM asociado a los modos normales. Para ello, debemos también construir un programa que obtenga las frecuencias de dichos modos, así como una función que de el CCM de un modo dado.\nPrimero, se define una función que regresa el valor máximo del producto \\(\\langle Q| Q \\rangle\\) para cierto plano de reflexión. Además, se define una función que regresa el valor esperado y que será usada más adelante.\n\ndef expectedval(vec,S):\n    return dot(np.conj(vec).T,dot(S,vec)).real\n\nθ = linspace(0,pi,300)\n\ndef CCMMax(q):\n    max = 0\n    for ang in θ:\n        σ = TensT(U(ang),σy)\n        if abs(expectedval(q,Id + σ)) > max:\n            max = abs(expectedval(q,Id + σ))\n            M = expectedval(q,Id + σ)\n    return M\n\nLuego, se define la función que calcula las frecuencias de un modo normal para un punto del espacio recíproco dado.\n\ndef EigenfrequenciesC3(k):\n\n  \"\"\"Función que regresa las eigenfrecuencias para un vector recíproco kz dado.\"\"\"\n\n  #Se define el tensor de esfuerzos de todo el sistema.\n\n  #Matriz con constante de fuerza considerando una rotación respecto al plano x - y.\n  φxy = pi/3\n  Kx2 = dot(T(φxy),dot(Kx,T(-φxy)))\n\n  #Matrices de fuerza para cada uno de los vectores en la red.\n  K23 = dot(U(pi),dot(Kx2,U(-pi)))     #Calculada tomando 2 como origen.\n  K12 = dot(U(pi/3),dot(Kx2,U(-pi/3))) #Calculada tomando 1 como origen.\n  K13 = dot(U(-pi/3),dot(Kx2,U(pi/3))) #Calculado tomando 3 como origen.\n\n  DicMat   = { 0: (K12 + K13)/m1,\n               1: -K12/sqrt(m1*m2),\n               2: -K13/sqrt(m1*m3)*exp(-1J*k*c),\n               3: -K12/sqrt(m1*m2),\n               4: (K23+K12)/m2,\n               5: -K23/sqrt(m2*m3),\n               6: -K13/sqrt(m1*m3)*exp(1J*k*c),\n               7: -K23/sqrt(m2*m3),\n               8: (K23 + K13)/m3 }\n\n  Dinteger = array([[0,1,2],\n                    [3,4,5],\n                    [6,7,8]])\n\n  Dm = [ [DicMat[i] for i in rw] for rw in Dinteger ]\n  Dynamical = asarray(np.bmat(Dm))\n\n  ω2,eigvecs = eigh(Dynamical)\n\n  return sqrt(abs(ω2))/2/pi,eigvecs\n\nSe definieron funciones que calculaba la polarización de fonón, la CCM y el pseudoescalar de momento angular dadas una frecuencia y un modo normal.\n\ndef CCM_general(ω,eigvecs):\n  CCM = []\n  for i in range(len(ω2)):\n    eigvec = eigvecs[:,i]\n    q1 = sqrt(m1) * eigvec[0:3]\n    q2 = sqrt(m2) * eigvec[3:6]\n    q3 = sqrt(m3) * eigvec[6:]\n\n    Q = [q1,q2,q3]\n\n    num = 0\n    den = 0\n\n    for q in Q:\n        num += CCMMax(q)\n        den += vdot(q,q).real\n\n    CCM.append(1 - (num/(2*den)))\n\n  return CCM\n\n\n# Primero se define una función que regresa el operador de polarización de fonón. \ndef OperadorPseudomomento(n):\n\n  Sz = array([[0,-1J,0],\n              [1J,0,0],\n              [0,0,0]],dtype=complex)\n\n  return np.kron(np.eye(n,dtype=complex),Sz)\n\nS = OperadorPseudomomento(3)\n\ndef Pol_general(ω,eigvecs):\n  Pol = []\n  for i in range(len(ω)):\n    eigvec = eigvecs[:,i]\n    Pol.append(expectedval(eigvec,S))\n\n  return Pol\n\n\ndef Pz_general(ω,eigvecs):\n  pzlist = []\n  for i in range(len(ω)):\n    eigvec = eigvecs[:,i]\n    ω = sqrt(abs(ω2[i]))/2/pi\n    q1 = sqrt(m1) * eigvec[0:3]\n    q2 = sqrt(m2) * eigvec[3:6]\n    q3 = sqrt(m3) * eigvec[6:]\n\n    Q = [q1,q2,q3]\n\n    pz = 0\n\n    for i in range(len(Q)):\n        pz = pz + M[i]*Q[i][2]*(X[i]*Q[i][1] - Y[i]*Q[i][0]).real\n    pzlist.append(pz)\n\n  return pzlist\n\nFinalmente, se muestra la gráfica de bandas para la cadena \\(C_{3}\\) junto con los respectivos valores de CCM en cada punto:\n\nKpoints = np.linspace(-pi/c,pi/c,500)\n\nKlabels = [r\"K/2\",r\"Γ\",r\"K/2\"]\nKticks = concatenate([[0],[250],[500]])\n\nBandasC3 = []\nEigvecsC3 = []\nCCMC3 = []\nPolC3 = []\nPzC3 = []\n\nKevaluateC3 = (list( map(EigenfrequenciesC3,Kpoints) ))\n\nfor ω2,eigvec in KevaluateC3:\n  BandasC3.append(ω2)\n  EigvecsC3.append(eigvec)\n\nfor i in range(len(BandasC3)):\n  CCMC3.append(CCM_general(BandasC3[i],EigvecsC3[i]))\n  PolC3.append(Pol_general(BandasC3[i],EigvecsC3[i]))\n  PzC3.append(Pz_general(BandasC3[i],EigvecsC3[i]))\n\nCCMC3 = array(CCMC3)\nBandasC3 = array(BandasC3)\nPolC3 = array(PolC3)\nPzC3 = array(PzC3)\n\n\nnumKC3,nbandsC3 = shape(BandasC3)\nkenumC3 = arange(numKC3)\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbandsC3):\n  graficaC3 = ax.scatter(kenumC3,BandasC3.T[j],c = PolC3.T[j],cmap = \"coolwarm\",vmax = 1, vmin = -1,s = 5)\nfig.colorbar(graficaC3)\nax.set_xticks(Kticks)\nax.set_xticklabels(Klabels,fontsize = 20);\n\n\n\n\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbandsC3):\n  graficaC3 = ax.scatter(kenumC3,BandasC3.T[j],c = CCMC3.T[j],cmap = \"Reds\",vmax = 1, vmin = 0,s = 5)\nfig.colorbar(graficaC3)\nax.set_xticks(Kticks)\nax.set_xticklabels(Klabels,fontsize = 20);\n\n\n\n\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbandsC3):\n  graficaC3 = ax.scatter(kenumC3,BandasC3.T[j],c = PzC3.T[j],cmap = \"coolwarm\",vmax = 0.1, vmin = -0.1,s = 5)\nfig.colorbar(graficaC3)\nax.set_xticks(Kticks)\nax.set_xticklabels(Klabels,fontsize = 20);\n\n/home/deigobau/anaconda3/envs/chiral/lib/python3.12/site-packages/matplotlib/cbook.py:1699: ComplexWarning:\n\nCasting complex values to real discards the imaginary part\n\n/home/deigobau/anaconda3/envs/chiral/lib/python3.12/site-packages/matplotlib/axes/_axes.py:4455: ComplexWarning:\n\nCasting complex values to real discards the imaginary part\n\n\n\n\n\n\nAhora, hacemos el estudio de quiralidad mediante el cálculo del Pseudomomento escalar. Dado un modo \\(k\\), este está determinado por \\[(\\sum p^{z}L^{z})_{k} = -(\\omega_{k})^{2}\\left[\\sum_{i}m_{i}c^{z}_{ki}\\left(x_{i}c^{y}_{k,i} - y_{i}c^{x}_{k,i}\\right)\\right].\\] Debajo, se define una función que calcula el valor del escalar de pseudomomento para cada valor de \\(k\\)."
  }
]