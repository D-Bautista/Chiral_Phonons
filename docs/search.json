[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Chiral_Phonons",
    "section": "",
    "text": "Introducción\nEn este libro se muestran los cálculos realizados por los estudiante Diego Bautista Avilés y Frida Fernanda García Lopez en colaboración con el Dr. José Eduardo Barrios Vargas y el Dr. Luis E. F. Foa Torre.\nPara el trabajo aquí realizado se agradece el apoyo a CONAHCYT por medio de una beca de proyecto CONAHCYT frontera.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "CadenasQuirales.html",
    "href": "CadenasQuirales.html",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "",
    "text": "1.1 Tensor de constantes de red para una cadena quiral\nLos tensores de constante de red para estos sistemas se calculan siguiendo la técnica expuesta por Saito en su libro Physical Properties of Carbon Nanotubes, la cual consiste en transformar el tensor de esfuerzos en su representación diagonal por matrices de rotación cuyos ángulos son obtenidos de las posiciones relativas entre dos átomos del sistema. Para las cadenas modeladas a continuación, se supuso que los enlaces de interacción entre los átomos formaban ángulos de \\(\\varphi = \\pi/3\\) respecto a los planos perpendiculares al eje de traslación. Asimismo, vistos desde arriba los tres sitios tenían ángulos de \\(\\theta = 2 \\pi / n\\) entre ellos donde \\(n\\) es el entero que define la simetría \\(C_{n}\\).\nSe asumió que todos los átomos de la cadena (4 como máximo para el caso de \\(C_{4}\\)) tenían la misma masa. Asimismo, se asumió que en todos los casos el tensor de constante de red en su representación diagonal se escribía como sigue: \\[K_{x} = \\begin{pmatrix}K_{L} & 0 & 0 \\\\\n0 & K_{T1} & 0 \\\\\n0 & 0 & K_{T2}\\end{pmatrix},\\] donde \\(K_{L} = 1\\), \\(K_{T1} = 0.05\\) y \\(K_{T2} = 0.25\\).\n#Constantes\nm1 = 1\nm2 = 1\nm3 = 1\nm4 = 1\nc = 1\n#Matriz de resortes a lo largo de x.\nKL = 1\nKT1 = 0.05\nKT2 = 0.25\n\nKx = array([[KL,0,0],\n              [0,KT1,0],\n              [0,0,KT2]],dtype=complex)\nSe definió una rotación en torno al eje y como \\[T(\\varphi) = \\begin{pmatrix} \\cos (\\varphi) & 0 & \\sin (\\varphi) \\\\\n0 & 1 & 0 \\\\\n- \\sin (\\varphi) & 0 & \\cos(\\varphi)\\end{pmatrix}.\\] De esta forma, la constante de fuerza \\[K_{x2} = T(\\varphi) K_{x} T(- \\varphi)\\] tiene un angulo de \\(\\varphi\\) respecto al plano x - y. Por otra parte, se definió la matriz de rotación respecto al eje - z como \\[U(\\theta) = \\begin{pmatrix} \\cos (\\theta) & - \\sin (\\theta) & 0 \\\\\n- \\sin (\\theta) & \\cos (\\theta) & 0 \\\\\n0 & 0 & 1\\end{pmatrix}.\\] De esta forma, si \\(\\theta\\) era el ángulo entre dos sitios, podía definirse la constante de red entre dichos sitios como \\[K = U(\\theta)K_{x2}U(-\\theta).\\]\n#Rotación de φ respecto al plano x - y.\nφxy = pi/3\n\ndef T(φ):\n  return array([[cos(φ) ,0.  ,sin(φ)],\n                [0.     ,1.  ,0],\n                [-sin(φ),0.  ,cos(φ)]])\n#Rotación respecto al eje z.\ndef U(θ):\n  return array([[cos(θ),-sin(θ),0],\n              [sin(θ),cos(θ),0],\n              [       0,      0,1]] )\n#Matriz de resortes a lo largo de x.\nKL = 1\nKT1 = 0.05\nKT2 = 0.25\n\nKx = array([[KL,0,0],\n              [0,KT1,0],\n              [0,0,KT2]],dtype=complex)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Cálculos de relación de dispersión de frecuencia en cadenas quirales</span>"
    ]
  },
  {
    "objectID": "CadenasQuirales.html#tensor-de-constantes-de-red-para-una-cadena-quiral",
    "href": "CadenasQuirales.html#tensor-de-constantes-de-red-para-una-cadena-quiral",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "1.1 Tensor de constantes de red para una cadena quiral",
    "text": "1.1 Tensor de constantes de red para una cadena quiral\nLos tensores de constante de red para estos sistemas se calculan siguiendo la técnica expuesta por Saito en su libro Physical Properties of Carbon Nanotubes, la cual consiste en transformar el tensor de esfuerzos en su representación diagonal por matrices de rotación cuyos ángulos son obtenidos de las posiciones relativas entre dos átomos del sistema. Para las cadenas modeladas a continuación, se supuso que los enlaces de interacción entre los átomos formaban ángulos de \\(\\varphi = \\pi/3\\) respecto a los planos perpendiculares al eje de traslación. Asimismo, vistos desde arriba los tres sitios tenían ángulos de \\(\\theta = 2 \\pi / n\\) entre ellos donde \\(n\\) es el entero que define la simetría \\(C_{n}\\).\nSe asumió que todos los átomos de la cadena (4 como máximo para el caso de \\(C_{4}\\)) tenían la misma masa. Asimismo, se asumió que en todos los casos el tensor de constante de red en su representación diagonal se escribía como sigue: \\[K_{x} = \\begin{pmatrix}K_{L} & 0 & 0 \\\\\n0 & K_{T1} & 0 \\\\\n0 & 0 & K_{T2}\\end{pmatrix},\\] donde \\(K_{L} = 1\\), \\(K_{T1} = 0.05\\) y \\(K_{T2} = 0.25\\).\n\n#Constantes\nm1 = 1\nm2 = 1\nm3 = 1\nm4 = 1\nc = 1\n\n\n#Matriz de resortes a lo largo de x.\nKL = 1\nKT1 = 0.05\nKT2 = 0.25\n\nKx = array([[KL,0,0],\n              [0,KT1,0],\n              [0,0,KT2]],dtype=complex)\n\nSe definió una rotación en torno al eje y como \\[T(\\varphi) = \\begin{pmatrix} \\cos (\\varphi) & 0 & \\sin (\\varphi) \\\\\n0 & 1 & 0 \\\\\n- \\sin (\\varphi) & 0 & \\cos(\\varphi)\\end{pmatrix}.\\] De esta forma, la constante de fuerza \\[K_{x2} = T(\\varphi) K_{x} T(- \\varphi)\\] tiene un angulo de \\(\\varphi\\) respecto al plano x - y. Por otra parte, se definió la matriz de rotación respecto al eje - z como \\[U(\\theta) = \\begin{pmatrix} \\cos (\\theta) & - \\sin (\\theta) & 0 \\\\\n- \\sin (\\theta) & \\cos (\\theta) & 0 \\\\\n0 & 0 & 1\\end{pmatrix}.\\] De esta forma, si \\(\\theta\\) era el ángulo entre dos sitios, podía definirse la constante de red entre dichos sitios como \\[K = U(\\theta)K_{x2}U(-\\theta).\\]\n\n#Rotación de φ respecto al plano x - y.\nφxy = pi/3\n\ndef T(φ):\n  return array([[cos(φ) ,0.  ,sin(φ)],\n                [0.     ,1.  ,0],\n                [-sin(φ),0.  ,cos(φ)]])\n\n\n#Rotación respecto al eje z.\ndef U(θ):\n  return array([[cos(θ),-sin(θ),0],\n              [sin(θ),cos(θ),0],\n              [       0,      0,1]] )\n\n\n#Matriz de resortes a lo largo de x.\nKL = 1\nKT1 = 0.05\nKT2 = 0.25\n\nKx = array([[KL,0,0],\n              [0,KT1,0],\n              [0,0,KT2]],dtype=complex)"
  },
  {
    "objectID": "CadenasQuirales.html#definición-de-la-matriz-dinámica",
    "href": "CadenasQuirales.html#definición-de-la-matriz-dinámica",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "1.2 Definición de la matriz dinámica",
    "text": "1.2 Definición de la matriz dinámica\nEn general, los elementos de la matriz dinámica tenían la forma \\[D_{ij} = - \\frac{K_{ij}}{\\sqrt{m_{i}m_{j}}}\\] para elementos fuera de la diagonal y \\[K_{ii} = \\frac{\\sum_{i\\neq j}Kij}{m_{i}}\\] para elementos fuera de la diagonal. En este último término la suma es solo sobre los primeros vecinos del elemento i. Asimismo, en caso de que la interacción fuera con un elemento fuera de la celda unitaria, se añadía la fase correspondiente.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Cálculos de relación de dispersión de frecuencia en cadenas quirales</span>"
    ]
  },
  {
    "objectID": "CadenasQuirales.html#definición-del-operador-de-polarización",
    "href": "CadenasQuirales.html#definición-del-operador-de-polarización",
    "title": "1  Cálculos de relación de dispersión de frecuencia en cadenas quirales",
    "section": "1.3 Definición del operador de polarización",
    "text": "1.3 Definición del operador de polarización\nLa quiralidad de los fonones se determina a partir de un valor no nulo de la polarización de fonón. Esta se obtiene apartir del valor esperado del operador de polarización. Este operador corresponde a la proyección sobre una base con movimiento circular bien definido. Para un sólo átomo, esta base es \\[| R \\rangle = \\frac{1}{\\sqrt{2}}(1,i)^{T}; | L \\rangle = \\frac{1}{\\sqrt{2}}(1,-i)^{T}.\\] Explícitamente, el operador de Polarización está dado por \\[\\hat{S}_{z} = \\sum_{\\alpha = 1}^{n} \\left(|R_{\\alpha}\\rangle \\langle R_{\\alpha}| -  |L_{\\alpha}\\rangle \\langle L_{\\alpha}|\\right).\\] La suma se hace sobre todos los sitios del sistema. Debajo, se muestran bloques de código donde se define un operador de pseudomomento para una cadena con \\(n\\) átomos, así como una función que calcula el valor esperado de un operador.\n\ndef OperadorPseudomomento(n):\n\n  Sz = array([[0,-1J,0],\n              [1J,0,0],\n              [0,0,0]],dtype=complex)\n\n  return np.kron(np.eye(n,dtype=complex),Sz)\n\ndef expectedval(vec,S):\n    return dot(np.conj(vec).T,dot(S,vec)).real",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Cálculos de relación de dispersión de frecuencia en cadenas quirales</span>"
    ]
  },
  {
    "objectID": "nanocinta.html",
    "href": "nanocinta.html",
    "title": "2  Descripción de una nanocinta de grafeno",
    "section": "",
    "text": "Este código busca describir los modos vibracionales de un ribbon de grafeno. Para ello, se usa la paquetería ASE para importar un objeto con las posiciones y masas del ribbon. Este ribbon se construye especificando los índices (n,m) que definen la celda unitaria. En el código, se implementa una función que calcula los primeros vecinos del ribbon, especificando si son intracelda o extracelda. Esto permite hacer una gráfica del objeto.\nPosteriormente, se define una función que consigue obtener el tensor de constante de red entre cualesquiera dos sitios. Para ello, se parte del tensor de esfuerzos de los carbonos en grafeno y se aplican las transformaciones pertinentes.\n\n#Primero, se importan las paqueterías a usar. \n\nfrom pylab import *\nfrom ase.build import graphene_nanoribbon\nimport plotly.graph_objects as go\nfrom numpy import linalg as LA\nfrom scipy.linalg import ishermitian\n\n\n#Se construye el objeto de nanotubo, se obtienen las posiciones y masas de cada átomo. \n\ncnt1     = graphene_nanoribbon(10,2, type='zigzag')\nr        = cnt1.get_positions()\nX,Y,Z    = cnt1.get_positions().T\nnsites   = len(X)\na1,a2,a3 = array(cnt1.get_cell())\n\ncluz = 3e10 #cm/\nmasas = cnt1.get_masses()\nmasas = 1.66e-27*masas\n\nprint(f\"nsites = {nsites}\")\nprint(f\"    a1 = {a1}\")\nprint(f\"    a2 = {a2}\")\nprint(f\"    a3 = {a3}\")\n\nnsites = 40\n    a1 = [0. 0. 0.]\n    a2 = [0. 0. 0.]\n    a3 = [0.         0.         4.91902429]\n\n\n\n#Debajo, se definen las funcioens que buscan los primeros vecinos. Además, se define la función que permite graficar el ribbon.\n\ndef findnn(X,Y,Z):\n  nn = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos],Y[todos],Z[todos]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas&lt;1.44 # distancia en Ang para encontrar los vecinos\n\n      nn[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn\n\ndef findnn_minus(X,Y,Z):\n  nn_minus_a3 = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos]+a3[0],Y[todos]+a3[1],Z[todos]+a3[2]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas&lt;1.44 # distancia en Ang para encontrar los vecinos\n\n      nn_minus_a3[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn_minus_a3\n\ndef findnn_plus(X,Y,Z):\n  nn_plus_a3 = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos]-a3[0],Y[todos]-a3[1],Z[todos]-a3[2]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas&lt;1.44 # distancia en Ang para encontrar los vecinos\n\n      nn_plus_a3[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn_plus_a3\n\ndef GetDATAplot(X,Y,Z,nn,nn_minus_a3,nn_plus_a3):\n  DATA = [go.Scatter3d(x=X, y=Y, z=Z,mode='markers',showlegend=False)]\n\n  for key in nn: # para cada sitio\n      for n in nn[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key],X[n]], y=[Y[key],Y[n]], z=[Z[key],Z[n]],mode='lines',line=dict(color='blue'),showlegend=False))\n\n  for key in nn_minus_a3: # para cada sitio\n      for n in nn_minus_a3[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key]+a3[0],X[n]], y=[Y[key]+a3[1],Y[n]], z=[Z[key]+a3[2],Z[n]],mode='lines',line=dict(color='red'),showlegend=False) )\n\n  for key in nn_plus_a3: # para cada sitio\n      for n in nn_plus_a3[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key]-a3[0],X[n]], y=[Y[key]-a3[1],Y[n]], z=[Z[key]-a3[2],Z[n]],mode='lines',line=dict(color='red'),showlegend=False) )\n\n  annos = []\n  # for n in range(len(X)):\n  for n in range(len(X)):\n    anno = dict(x=X[n],\n                y=Y[n],\n                z=Z[n],\n                text=str(n),\n                showarrow=False,\n                arrowhead=0,\n                font=dict(color='black'),\n                ax=0,\n                ay=0,\n                bgcolor=\"white\",\n                opacity=0.2)\n\n    annos.append(anno)\n\n  return DATA,annos\n\n\n#Los primeros vecinos se almacenan en un diccionario. \n\nnn = findnn(X,Y,Z)\nnn_minus_a3 = findnn_minus(X,Y,Z)\nnn_plus_a3  = findnn_plus(X,Y,Z)\n\n\n#Se construye la imagen del ribbon. \n\nDATA,annos = GetDATAplot(X,Y,Z,nn,nn_minus_a3,nn_plus_a3)\nfig = go.Figure(data=DATA)\nfig.update_layout(scene=dict(annotations=annos))\nfig.show()\n\n                                                \n\n\n\n#Se define la función que calcula el tensor de constante de red para cualesquiera dos puntos. \n\nKL1 = 365.0 #N/m\nKT1 = 245.0 #N/m\nKZ1 = 98.2 #N/m\n\nKrib = array([[KL1,0,0],\n            [0,KZ1,0],\n            [0,0,KT1]],dtype=complex)\n\ndef KGeneral(r1,r2):\n  \n  x1,z1 = r1[0],r1[2]\n  x2,z2 = r2[0],r2[2]\n\n  x = x2 - x1\n  z = z2 - z1\n\n  θ = arctan(z/x)\n\n  T = array([[cos(θ) ,0.  ,-sin(θ)],\n                [0.     ,1.  ,0],\n                [sin(θ),0.  ,cos(θ)]],dtype = complex)\n\n  return dot(T,dot(Krib,inv(T)))\n\n\n#Ahora, se calcula una función que construye la matriz dinámica para cada punto en el espacio k, y obtiene las eigenfrecuencias y pseudomomento asociado. \n\n#Para ello, se definen una función que calcula la polarización de fonón y otra que calcula el valor esperado. \n\ndef OperadorPseudomomento(n):\n\n  Sz = array([[0,-1J,0],\n              [1J,0,0],\n              [0,0,0]],dtype=complex)\n\n  return np.kron(np.eye(n,dtype=complex),Sz)\n\nS = OperadorPseudomomento(nsites)\n\ndef expectedval(vec,S):\n    return dot(np.conj(vec).T,dot(S,vec)).real\n\ndef Eigenfrequencies(kvec):\n  MatrizDinamica = {}\n  MatInt = array(range(nsites*nsites)).reshape(nsites,nsites)\n\n  for i in range(len(X)):\n\n    ri = [X[i],Y[i],Z[i]]\n\n    Kdiagi = np.zeros((3,3))\n\n    for n in nn[i]:\n      rn = [X[n],Y[n],Z[n]]\n      Kdiagi = Kdiagi + KGeneral(ri,rn)\n    for n in nn_plus_a3[i]:\n      rn = [X[n],Y[n],Z[n]] + a3\n      Kdiagi = Kdiagi + KGeneral(ri,rn)\n    for n in nn_minus_a3[i]:\n      rn = [X[n],Y[n],Z[n]] - a3\n      Kdiagi = Kdiagi + KGeneral(ri,rn)\n\n    MatrizDinamica[(nsites)*i + i] = Kdiagi/masas[i]\n\n    for j in range(i+1,len(X)):\n      rj = [X[j],Y[j],Z[j]]\n      if j in nn[i]:\n        K = -1*KGeneral(ri,rj)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*i + j] = -1*KGeneral(ri,rj)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*j + i] = K\n      elif j in nn_plus_a3[i]:\n        K = -1*KGeneral(ri,rj + a3)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*i + j] = K*exp(1J*kvec)\n        MatrizDinamica[(nsites)*j + i] = K*exp(-1J*kvec)\n      elif j in nn_minus_a3[i]:\n        K = -1*KGeneral(ri,rj - a3)/sqrt(masas[i]*masas[j])\n        MatrizDinamica[(nsites)*i + j] = K*exp(-1J*kvec)\n        MatrizDinamica[(nsites)*j + i] = K*exp(1J*kvec)\n      else:\n          MatrizDinamica[(nsites)*i + j] = np.zeros((3,3))\n          MatrizDinamica[(nsites)*j + i] = np.zeros((3,3))\n\n  MatrizDinamica = dict(sorted(MatrizDinamica.items()))\n\n  Dm = [ [MatrizDinamica[i] for i in rw] for rw in MatInt ]\n  Dynamical = asarray(np.bmat(Dm))\n\n  ω2,eigvecs = eigh(Dynamical)\n\n  pseudomom = []\n\n\n  for i in range(len(ω2)):\n    eigvec = eigvecs[:,i]\n    pseudomom.append(expectedval(eigvec,S))\n\n\n  return sqrt(abs(ω2))/2/pi/cluz,pseudomom\n\n\n#Finalmente, se hace el cálculo de las bandas de frecuencia.\n\nKpoints = np.linspace(-pi,pi,500)\n\nKlabels = [r\"K/2\",r\"Γ\",r\"K/2\"]\nKticks = concatenate([[0],[250],[500]])\n\nBandas = []\nPseudomom = []\n\nKevaluate = (list( map(Eigenfrequencies,Kpoints) ))\n\nfor ω2,psmom in Kevaluate:\n  Bandas.append(ω2)\n  Pseudomom.append(psmom)\n\nBandas = array(Bandas)\nPseudomom = array(Pseudomom)\n\nnumK,nbands = shape(Bandas)\nkenum = arange(numK)\n\nfig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))\nfor j in range(nbands):\n  grafica = ax.scatter(kenum,Bandas.T[j],c = Pseudomom.T[j],cmap = \"coolwarm\",vmax = 1, vmin = -1,s = 5)\nfig.colorbar(grafica)\nax.set_xticks(Kticks)\n#ax.set_ylim(1,100)\nax.set_xticklabels(Klabels,fontsize = 20);",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Descripción de una nanocinta de grafeno</span>"
    ]
  },
  {
    "objectID": "PruebasKGeneral.html",
    "href": "PruebasKGeneral.html",
    "title": "3  Pruebas realizadas sobre un nanotubo",
    "section": "",
    "text": "from pylab import *\nfrom ase.build import nanotube\nfrom ase.build import graphene_nanoribbon\nimport plotly.graph_objects as go\nfrom numpy import linalg as LA\nfrom scipy.linalg import ishermitian\n\n\ncnt1 = nanotube(4,2, length=1)\n#cnt1     = graphene_nanoribbon(10,2, type='zigzag')\nr        = cnt1.get_positions()\nX,Y,Z    = cnt1.get_positions().T\nnsites   = len(X)\na1,a2,a3 = array(cnt1.get_cell())\n\nmasas = cnt1.get_masses()\n\nprint(f\"nsites = {nsites}\")\nprint(f\"    a1 = {a1}\")\nprint(f\"    a2 = {a2}\")\nprint(f\"    a3 = {a3}\")\n\nnsites = 56\n    a1 = [0. 0. 0.]\n    a2 = [0. 0. 0.]\n    a3 = [ 0.          0.         11.27090059]\n\n\n\ndef findnn(X,Y,Z):\n  nn = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos],Y[todos],Z[todos]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas&lt;1.44 # distancia en Ang para encontrar los vecinos\n\n      nn[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn\n\ndef findnn_minus(X,Y,Z):\n  nn_minus_a3 = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos]+a3[0],Y[todos]+a3[1],Z[todos]+a3[2]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas&lt;1.44 # distancia en Ang para encontrar los vecinos\n\n      nn_minus_a3[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn_minus_a3\n\ndef findnn_plus(X,Y,Z):\n  nn_plus_a3 = {}\n  for todos in range(len(X)):\n\n      UnSitio     = array([X[todos]-a3[0],Y[todos]-a3[1],Z[todos]-a3[2]])\n      DataUnSitio = kron(ones(nsites),UnSitio)\n      DataUnSitio = DataUnSitio.reshape(nsites,3)\n\n      Dif = DataUnSitio - array([X,Y,Z]).T\n      normas = []\n      for n in range(len(Dif)):\n          norm = sqrt(dot(Dif[n],Dif[n]))\n          normas.append(norm)\n      normas  = array(normas)\n      logical = normas&lt;1.44 # distancia en Ang para encontrar los vecinos\n\n      nn_plus_a3[todos] = delete( logical.nonzero()[0], \\\n          where(logical.nonzero()[0] == todos) )\n  return nn_plus_a3\n\ndef GetDATAplot(X,Y,Z,nn,nn_minus_a3,nn_plus_a3):\n  DATA = [go.Scatter3d(x=X, y=Y, z=Z,mode='markers',showlegend=False)]\n\n  for key in nn: # para cada sitio\n      for n in nn[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key],X[n]], y=[Y[key],Y[n]], z=[Z[key],Z[n]],mode='lines',line=dict(color='blue'),showlegend=False))\n\n  for key in nn_minus_a3: # para cada sitio\n      for n in nn_minus_a3[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key]+a3[0],X[n]], y=[Y[key]+a3[1],Y[n]], z=[Z[key]+a3[2],Z[n]],mode='lines',line=dict(color='red'),showlegend=False) )\n\n  for key in nn_plus_a3: # para cada sitio\n      for n in nn_plus_a3[key]: # para cada vecino\n          DATA.append( go.Scatter3d(x=[X[key]-a3[0],X[n]], y=[Y[key]-a3[1],Y[n]], z=[Z[key]-a3[2],Z[n]],mode='lines',line=dict(color='red'),showlegend=False) )\n\n  annos = []\n  # for n in range(len(X)):\n  for n in range(len(X)):\n    anno = dict(x=X[n],\n                y=Y[n],\n                z=Z[n],\n                text=str(n),\n                showarrow=False,\n                arrowhead=0,\n                font=dict(color='black'),\n                ax=0,\n                ay=0,\n                bgcolor=\"white\",\n                opacity=0.2)\n\n    annos.append(anno)\n\n  return DATA,annos\n\n\nnn = findnn(X,Y,Z)\nnn_minus = findnn_minus(X,Y,Z)\nnn_plus  = findnn_plus(X,Y,Z)\n\n\n#KL1 = 365.0 #N/m\n#KT1 = 245.0 #N/m\n#KZ1 = 98.2 #N/m\n\nKL1 = 1 #N/m\nKT1 = 0 #N/m\nKZ1 = 0 #N/m\n\nKbase = array([[KL1,0,0],\n              [0,KT1,0],\n              [0,0,KZ1]],dtype=complex)\n\ndef KGeneral(r1,r2):\n\n  x1,y1,z1 = r1[0],r1[1],r1[2]\n  x2,y2,z2 = r2[0],r2[1],r2[2]\n\n  x12 = x2 - x1\n  y12 = y2 - y1\n  z12 = z2 - z1\n\n  rij = [x12,y12,z12]\n\n  zhat = [0,0,1]\n  ρhat = [x1,y1,0]/LA.norm([x1,y1,0]).T\n  θhat = np.cross(zhat,ρhat)\n\n  M = array([θhat,zhat,ρhat]).T #Matriz de cambio de base\n\n  φ = arcsin(dot(rij,ρhat)/LA.norm(rij)) #Angulo que hace Kx con el plano perpendicular a rho.\n\n  T = array([[cos(φ) ,0.  ,-sin(φ)],\n                [0.     ,1.  ,0],\n                [sin(φ),0.  ,cos(φ)]],dtype = complex)\n\n  w = rij - dot(rij,ρhat)*ρhat #Componente del vector dentro del plano\n\n  xi = dot(w,θhat)\n  yi = dot(w,zhat)\n\n  θ = arcsin(yi/sqrt(xi**2 + yi**2))\n\n  U = array([[cos(θ),-sin(θ),0],\n              [sin(θ),cos(θ),0],\n              [       0,      0,1]],dtype = complex)\n\n  print(f\"φ = {φ*180/pi}\")\n  print(f\"θ = {θ*180/pi}\")\n  print(f\"θhat = {θhat}\")\n  print(f\"ρhat = {ρhat}\")\n  \n\n\n  Krotplano = dot(inv(T),dot(Kbase,inv(T)))\n\n  Krotpolar = dot(U,dot(Krotplano,inv(U)))\n\n  print(f\"Vector θhat rotado = {(dot(M,dot(T,dot(U,[1,0,0]))).real)}\")\n  print(f\"Vector ρhat rotado = {(dot(M,dot(T,dot(U,[0,0,1])))).real}\")\n  print(f\"Vector zhat rotado = {(dot(M,dot(T,dot(U,[0,1,0])))).real}\")\n\n\n  return dot(M,dot(Krotpolar,inv(M)))\n\n\nDATA,annos = GetDATAplot(X,Y,Z,nn,nn_minus,nn_plus)\nfig = go.Figure(data=DATA)\nfig.update_layout(scene=dict(annotations=annos))\nfig.show()\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\ndef HacerPrueba(r1,r2):\n    KGeneral(r1,r2)\n    print(KGeneral(r1,r2))\n    print(\"--------------------------\")\n    print(KGeneral(r2,r1))\n    return KGeneral(r1,r2)\n\n\nrij = (r[43] - r[50])/LA.norm(r[50] - r[43])\na = HacerPrueba(r[43],r[50])\n\nφ = -2.096366923617549\nθ = -71.04187975084295\nθhat = [ 0.78183148  0.6234898  -0.        ]\nρhat = [ 0.6234898  -0.78183148  0.        ]\nVector θhat rotado = [ 0.24641941  0.21171327 -0.94575629]\nVector ρhat rotado = [ 0.65167217 -0.75850074  0.        ]\nVector zhat rotado = [0.71735685 0.61632306 0.32487695]\nφ = -2.096366923617549\nθ = -71.04187975084295\nθhat = [ 0.78183148  0.6234898  -0.        ]\nρhat = [ 0.6234898  -0.78183148  0.        ]\nVector θhat rotado = [ 0.24641941  0.21171327 -0.94575629]\nVector ρhat rotado = [ 0.65167217 -0.75850074  0.        ]\nVector zhat rotado = [0.71735685 0.61632306 0.32487695]\n[[ 0.063909  +0.j  0.063909  +0.j -0.26145561+0.j]\n [ 0.04015668+0.j  0.04015668+0.j -0.16428345+0.j]\n [-0.21834386+0.j -0.21834386+0.j  0.89325808+0.j]]\n--------------------------\nφ = -2.096366923617541\nθ = 71.04187975084295\nθhat = [ 0.6234898   0.78183148 -0.        ]\nρhat = [ 0.78183148 -0.6234898   0.        ]\nVector θhat rotado = [0.19313053 0.26123865 0.94575629]\nVector ρhat rotado = [ 0.80411568 -0.59447285  0.        ]\nVector zhat rotado = [-0.56222644 -0.76049747  0.32487695]\n[[0.04015668+0.j 0.063909  +0.j 0.21834386+0.j]\n [0.04015668+0.j 0.063909  +0.j 0.21834386+0.j]\n [0.16428345+0.j 0.26145561+0.j 0.89325808+0.j]]\nφ = -2.096366923617549\nθ = -71.04187975084295\nθhat = [ 0.78183148  0.6234898  -0.        ]\nρhat = [ 0.6234898  -0.78183148  0.        ]\nVector θhat rotado = [ 0.24641941  0.21171327 -0.94575629]\nVector ρhat rotado = [ 0.65167217 -0.75850074  0.        ]\nVector zhat rotado = [0.71735685 0.61632306 0.32487695]\n\n\n\nrij\n\narray([-0.23102156, -0.23102156,  0.94512331])\n\n\n\ndot(a,rij)\n\narray([-0.2766365 +0.j, -0.17382223+0.j,  0.94512331+0.j])",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Pruebas realizadas sobre un nanotubo</span>"
    ]
  }
]