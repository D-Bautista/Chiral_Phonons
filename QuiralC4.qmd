# Cálculo de CCM para una cadena quiral C4

```{python}
from pylab import *
import plotly.graph_objects as go
```

 En este capítulo se estudiará la quiralidad de los modos normales de una cadena quiral con simetría $C_{3}$. Los criterios usados son la polarización de fonón, el CCM y el pseudoescalar de momento angular.

Debajo, se definen varias constantes a emplear. Dentro de estas están las masas de los sitios, la longitud de los lados del ángulo vista desde arriba, las constantes de resorte y el ángulo de los enlaces respecto al plano x - y. Además, se definen las posiciones los tres átomos dentro de la celda unitaria, y dos átomos de celdas vecinas. 

```{python}
# Masas de los distintos sitios. 
m1 = 1
m2 = 1
m3 = 1
m4 = 1

M = [m1,m2,m3,m4]

# Matriz de resortes a lo largo de x.
KL = 1
KT1 = 0.05
KT2 = 0.25

# Tensor de constante de red en configuración usual. 
Kx = array([[KL,0,0],
              [0,KT1,0],
              [0,0,KT2]],dtype=complex)

# Longitud de los enlaces proyectados al plano
a = 1

# Ángulo de los enlaces respecto al plano x - y.
φxy = pi/3

# Longitud de la celda unitaria.
c = 4 * a * tan(φxy)

#Rotación de φ respecto al plano x - y.
def T(φ):
  return array([[cos(φ) ,0.  ,sin(φ)],
                [0.     ,1.  ,0],
                [-sin(φ),0.  ,cos(φ)]])

                #Rotación respecto al eje z.
def U(θ):
  return array([[cos(θ),-sin(θ),0],
              [sin(θ),cos(θ),0],
              [       0,      0,1]] )


# Posiciones de los átomos en la celda unitaria de la cadena.
r1 = array([1,0,0])
r2 = dot(U(2*pi/4),r1) + array([0,0,c/4])
r3 = dot(U(2*2*pi/4),r1)+ array([0,0,2*c/4])
r4 = dot(U(3*2*pi/4),r1)+ array([0,0,3*c/4])

# Posición de los átomos en la celda vecina. 
r1plus = r1 + [0,0,c]
r4minus = r4 - [0,0,c]

positions = array([r1,r2,r3,r4])

positionsnn = array([r4minus,r1plus])

X,Y,Z = positions.T
Xnn,Ynn,Znn = positionsnn.T
```

Debajo, se muestra una imagen de la cadena. 

```{python}
DATA = [go.Scatter3d(x=X, y=Y, z=Z,mode='markers',marker_color = "blue",showlegend=False)]

DATA.append(go.Scatter3d(x=Xnn, y=Ynn, z=Znn,mode='markers',marker_color = "red",showlegend=False))

DATA.append(go.Scatter3d(x= [X[0],Xnn[0]], y=[Y[0],Ynn[0]], z=[Z[0],Znn[0]],mode='lines',line=dict(color='red'),showlegend=False))

DATA.append(go.Scatter3d(x= [X[0],X[1]], y=[Y[0],Y[1]], z=[Z[0],Z[1]],mode='lines',line=dict(color='blue'),showlegend=False))

DATA.append(go.Scatter3d(x= [X[2],X[1]], y=[Y[2],Y[1]], z=[Z[2],Z[1]],mode='lines',line=dict(color='blue'),showlegend=False))

DATA.append(go.Scatter3d(x= [X[2],X[3]], y=[Y[2],Y[3]], z=[Z[2],Z[3]],mode='lines',line=dict(color='blue'),showlegend=False))

DATA.append(go.Scatter3d(x= [X[3],Xnn[1]], y=[Y[3],Ynn[1]], z=[Z[3],Znn[1]],mode='lines',line=dict(color='red'),showlegend=False))
```

```{python}
fig = go.Figure(data=DATA)
fig.show()
```

## Cálculo de CCM de la estructura

```{python}

#Matriz identidad.
Id = array([[1,0,0],
            [0,1,0],
            [0,0,1]] )

#Reflexión respecto al plano x - z.
σy = array([[-1,0,0],
            [0,1,0],
            [0,0,1]] )

def TensT(O,A):
  """Función que aplica transforma por un operador O a un tensor A."""
  return dot( inv(O), dot(A,O) )
```

Ya con todas las funciones a usar bien definidas, se hace el cálculo de la CCM De la estructura. Para ello, primero se calculan las coordenadas respecto al centro de masa. 

```{python}
# Centro de masa
RCM = (m1*r1 + m2*r2 + m3*r3 + m4*r4)/(m1 + m2 + m3 + m4)

# Coordenada Relativa 1
qrcm1 = sqrt(m1)*(r1 - RCM)

# Coordenada Relativa 2
qrcm2 = sqrt(m2)*(r2 - RCM)

# Coordenada Relativa 3
qrcm3 = sqrt(m3)*(r3 - RCM)

# Coordenada Relativa 4
qrcm4 = sqrt(m4)*(r4 - RCM)

# Lista con las coordenadas relativas. 
Qrcm = [qrcm1,qrcm2,qrcm3,qrcm4]
```

Queremos calcular la CCM tal que el plano de inversión elegido maximize la superposición de la estructura con la estructura invertida. Para ello, se define una función que calcula el CCM de la estructura tomando una reflexión respecto a un plano de entrada. 
```{python}
def CCMS(σ):
    num = 0
    den = 0
    for q in Qrcm:
        num = num + dot(q,dot(Id + σ,q))
        den = den + dot(q,q)
    return 1 - (num/(2*den))
```

Ya hecho esto, se calcula el CCM de la estructura. Notamos que para esta cadena el CCM es igual sin importar que plano de reflexión se use. Esto se ve en la gráfica mostrada debajo. 

```{python}
θ = linspace(0,pi,300)

σ = []

for ang in θ:
    σ.append(TensT(U(ang),σy))
σ = array(σ)

CCM_estructura = []

for ref in σ:
    CCM_estructura.append(CCMS(ref))

print("La CCM de la estructura es", str(np.min(CCM_estructura)))
```

```{python}
Labels = [r"0",r"π/2",r"π"]
Ticks = concatenate([[0],[pi/2],[pi]])

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(6,4.5))
ax.plot(θ,CCM_estructura)
ax.set_xticks(Ticks)
ax.set_ylim([0,1])
ax.set_xticklabels(Labels,fontsize = 20);
ax.set_ylabel("CCM",fontsize = 20)
plt.show()
```

## Cálculos del CCM de los modos vibracionales

Ahora calculamos el CCM asociado a los modos normales. Para ello, debemos también construir un programa que obtenga las frecuencias de dichos modos, así como una función que de el CCM de un modo dado.

Primero, se define una función que regresa el valor máximo del producto $\langle Q| Q \rangle$ para cierto plano de reflexión. Además, se define una función que regresa el valor esperado y que será usada más adelante. 

```{python}
def expectedval(vec,S):
    return dot(np.conj(vec).T,dot(S,vec)).real

θ = linspace(0,pi,300)

def CCMMax(q):
    max = 0
    for ang in θ:
        σ = TensT(U(ang),σy)
        if abs(expectedval(q,Id + σ)) > max:
            max = abs(expectedval(q,Id + σ))
            M = expectedval(q,Id + σ)
    return M
```

Luego, se define la función que calcula las frecuencias de un modo normal para un punto del espacio recíproco dado. 

```{python}
def EigenfrequenciesC4(k):

  """Función que regresa las eigenfrecuencias para un vector recíproco kz dado."""

  #Se define el tensor de esfuerzos de todo el sistema.

  #Matriz con constante de fuerza considerando una rotación respecto al plano x - y.
  φxy = pi/3
  Kx2 = dot(T(φxy),dot(Kx,T(-φxy)))

  #Matrices de fuerza para cada uno de los vectores en la red.
  K12 = dot(U(0),dot(Kx2,U(0)))
  K13 = np.zeros((3, 3))
  K14 = dot(U(pi/2),dot(Kx2,U(-pi/2)))

  K23 = dot(U(pi/2),dot(Kx2,U(-pi/2)))
  K24 = np.zeros((3, 3))

  K34 = dot(U(pi),dot(Kx,U(-pi)))

  DicMat   = { 0: (K12 + K13 + K14)/m1,
               1: -K12/sqrt(m1*m2),
               2: -K13/sqrt(m1*m3),
               3: -K14/sqrt(m1*m4)*exp(-1J*k*c),
               4: -K12.conj().T/sqrt(m1*m2),
               5: (K12 + K23 + K24)/m2,
               6: -K23/sqrt(m2*m3),
               7: -K24/sqrt(m2*m4),
               8: -K13.conj().T/sqrt(m3*m1),
               9: -K23.conj().T/sqrt(m3*m2),
               10: (K13 + K23 + K34)/m3,
               11: -K34/sqrt(m3*m4),
               12: -K14.conj().T/sqrt(m4*m1)*exp(1J*k*c),
               13: -K24.conj().T/sqrt(m4*m2),
               14: -K34.conj().T/sqrt(m4*m3),
               15: (K14 + K24 + K34)/m4}


  Dinteger = array([[0,1,2,3],
                    [4,5,6,7],
                    [8,9,10,11],
                    [12,13,14,15]])

  Dm = [ [DicMat[i] for i in rw] for rw in Dinteger ]
  Dynamical = asarray(np.bmat(Dm))


  ω2,eigvecs = eigh(Dynamical)

  return sqrt(abs(ω2))/2/pi,eigvecs
```

Se definieron funciones que calculaba la polarización de fonón, la CCM y el pseudoescalar de momento angular dadas una frecuencia y un modo normal. 

```{python}
def CCM_general(ω,eigvecs):
  CCM = []
  for i in range(len(ω2)):
    eigvec = eigvecs[:,i]
    q1 = sqrt(m1) * eigvec[0:3]
    q2 = sqrt(m2) * eigvec[3:6]
    q3 = sqrt(m3) * eigvec[6:9]
    q4 = sqrt(m3) * eigvec[9:]

    Q = [q1,q2,q3,q4]

    num = 0
    den = 0

    for q in Q:
        num += CCMMax(q)
        den += vdot(q,q).real

    CCM.append(1 - (num/(2*den)))

  return CCM
```

```{python}
# Primero se define una función que regresa el operador de polarización de fonón. 
def OperadorPseudomomento(n):

  Sz = array([[0,-1J,0],
              [1J,0,0],
              [0,0,0]],dtype=complex)

  return np.kron(np.eye(n,dtype=complex),Sz)

S = OperadorPseudomomento(4)

def Pol_general(ω,eigvecs):
  Pol = []
  for i in range(len(ω)):
    eigvec = eigvecs[:,i]
    Pol.append(expectedval(eigvec,S))

  return Pol
```
```{python}
def Pz_general(ω,eigvecs):
  pzlist = []
  for i in range(len(ω)):
    eigvec = eigvecs[:,i]
    ω = sqrt(abs(ω2[i]))/2/pi
    q1 = sqrt(m1) * eigvec[0:3]
    q2 = sqrt(m2) * eigvec[3:6]
    q3 = sqrt(m3) * eigvec[6:9]
    q4 = sqrt(m3) * eigvec[9:]

    Q = [q1,q2,q3,q4]

    pz = 0

    for i in range(len(Q)):
        pz = pz + M[i]*Q[i][2]*(X[i]*Q[i][1] - Y[i]*Q[i][0]).real
    pzlist.append(pz)

  return pzlist
```


```{python}
Kpoints = np.linspace(-pi/c,pi/c,500)

#Klabels = [r"K/2",r"Γ",r"K/2"]
Klabels = [r"-π/c",r"Γ",r"π/c"]
Kticks = concatenate([[0],[250],[500]])

BandasC4 = []
EigvecsC4 = []
CCMC4 = []
PolC4 = []
PzC4 = []

KevaluateC4 = (list( map(EigenfrequenciesC4,Kpoints) ))

for ω2,eigvec in KevaluateC4:
  BandasC4.append(ω2)
  EigvecsC4.append(eigvec)

for i in range(len(BandasC4)):
  CCMC4.append(CCM_general(BandasC4[i],EigvecsC4[i]))
  PolC4.append(Pol_general(BandasC4[i],EigvecsC4[i]))
  PzC4.append(Pz_general(BandasC4[i],EigvecsC4[i]))

CCMC4 = array(CCMC4)
BandasC4 = array(BandasC4)
PolC4 = array(PolC4)
PzC4 = array(PzC4)
```

```{python}
numKC4,nbandsC4 = shape(BandasC4)
kenumC4 = arange(numKC4)

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))
for j in range(nbandsC4):
  graficaC4 = ax.scatter(kenumC4,BandasC4.T[j],c = PolC4.T[j],cmap = "coolwarm",vmax = 1, vmin = -1,s = 5)
fig.colorbar(graficaC4)
ax.set_xticks(Kticks)
ax.set_xticklabels(Klabels,fontsize = 20);
```

```{python}
numKC4,nbandsC4 = shape(BandasC4)
kenumC4 = arange(numKC4)

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))
for j in range(nbandsC4):
  graficaC4 = ax.scatter(kenumC4,BandasC4.T[j],c = CCMC4.T[j],cmap = "Reds",vmax = 1, vmin = 0,s = 5)
fig.colorbar(graficaC4)
ax.set_xticks(Kticks)
ax.set_xticklabels(Klabels,fontsize = 20);
```

```{python}
numKC4,nbandsC4 = shape(BandasC4)
kenumC4 = arange(numKC4)

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))
for j in range(nbandsC4):
  graficaC4 = ax.scatter(kenumC4,BandasC4.T[j],c = PzC4.T[j],cmap = "coolwarm",vmax = 1, vmin = -1,s = 5)
fig.colorbar(graficaC4)
ax.set_xticks(Kticks)
ax.set_xticklabels(Klabels,fontsize = 20);
```

