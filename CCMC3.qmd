# Cálculo de CCM para una cadena quiral C3

```{python}
from pylab import *

```

Los cálculos de la estructura de bandas 

```{python}
#Constantes
m1 = 1
m2 = 1
m3 = 1

c = 1
```

```{python}
#Matriz de resortes a lo largo de x.
KL = 1
KT1 = 0.05
KT2 = 0.25

Kx = array([[KL,0,0],
              [0,KT1,0],
              [0,0,KT2]],dtype=complex)
```

```{python}
#Rotación de φ respecto al plano x - y.
φxy = pi/3

def T(φ):
  return array([[cos(φ) ,0.  ,sin(φ)],
                [0.     ,1.  ,0],
                [-sin(φ),0.  ,cos(φ)]])
```

```{python}
#Rotación respecto al eje z.
def U(θ):
  return array([[cos(θ),-sin(θ),0],
              [sin(θ),cos(θ),0],
              [       0,      0,1]] )

```

```{python}
#Matriz de resortes a lo largo de x.
KL = 1
KT1 = 0.05
KT2 = 0.25

Kx = array([[KL,0,0],
              [0,KT1,0],
              [0,0,KT2]],dtype=complex)
```

```{python}

def OperadorPseudomomento(n):

  Sz = array([[0,-1J,0],
              [1J,0,0],
              [0,0,0]],dtype=complex)

  return np.kron(np.eye(n,dtype=complex),Sz)

def expectedval(vec,S):
    return dot(np.conj(vec).T,dot(S,vec)).real
```

# Cálculos para la simetría $C_{3}$

Debajo se muestra un bloque de código donde se define una función que construye y diagonaliza la matriz dinámica para una cadena con simetría $C_{2}$, y que además obtiene la polarización de los modos vibracionales. 

```{python}
def EigenfrequenciesC3(k):

  """Función que regresa las eigenfrecuencias para un vector recíproco kz dado."""

  #Se define el tensor de esfuerzos de todo el sistema.

  #Matriz con constante de fuerza considerando una rotación respecto al plano x - y.
  φxy = pi/3
  Kx2 = dot(T(φxy),dot(Kx,T(-φxy)))

  #Matrices de fuerza para cada uno de los vectores en la red.
  K23 = dot(U(pi),dot(Kx2,U(-pi)))     #Calculada tomando 2 como origen.
  K12 = dot(U(pi/3),dot(Kx2,U(-pi/3))) #Calculada tomando 1 como origen.
  K13 = dot(U(-pi/3),dot(Kx2,U(pi/3))) #Calculado tomando 3 como origen.

  DicMat   = { 0: (K12 + K13)/m1,
               1: -K12/sqrt(m1*m2),
               2: -K13/sqrt(m1*m3)*exp(-1J*k*c),
               3: -K12/sqrt(m1*m2),
               4: (K23+K12)/m2,
               5: -K23/sqrt(m2*m3),
               6: -K13/sqrt(m1*m3)*exp(1J*k*c),
               7: -K23/sqrt(m2*m3),
               8: (K23 + K13)/m3 }

  Dinteger = array([[0,1,2],
                    [3,4,5],
                    [6,7,8]])

  Dm = [ [DicMat[i] for i in rw] for rw in Dinteger ]
  Dynamical = asarray(np.bmat(Dm))

  ω2,eigvecs = eigh(Dynamical)

  #Se definen los operadores de Pseudomomento.

  S = OperadorPseudomomento(3)

  pseudomom = []


  for i in range(len(ω2)):
    eigvec = eigvecs[:,i]
    pseudomom.append(expectedval(eigvec,S))

  return sqrt(abs(ω2))/2/pi,pseudomom
```

Finalmente, se muestra la gráfica de bandas para la cadena $C_{3}:

```{python}
Kpoints = np.linspace(-pi/c,pi/c,500)

Klabels = [r"K/2",r"Γ",r"K/2"]
Kticks = concatenate([[0],[250],[500]])

BandasC3 = []
PseudomomC3 = []

KevaluateC3 = (list( map(EigenfrequenciesC3,Kpoints) ))

for ω2,psmom in KevaluateC3:
  BandasC3.append(ω2)
  PseudomomC3.append(psmom)

BandasC3 = array(BandasC3)
PseudomomC3 = array(PseudomomC3)

numKC3,nbandsC3 = shape(BandasC3)
kenumC3 = arange(numKC3)

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))
for j in range(nbandsC3):
  graficaC3 = ax.scatter(kenumC3,BandasC3.T[j],c = PseudomomC3.T[j],cmap = "coolwarm",vmax = 1, vmin = -1,s = 5)
fig.colorbar(graficaC3)
ax.set_xticks(Kticks)
ax.set_xticklabels(Klabels,fontsize = 20);
```