# Cálculo de CCM para una cadena quiral C3

```{python}
from pylab import *
import plotly.graph_objects as go
```

Los cálculos de la estructura de bandas se realizan de forma análoga a los descritos en el capítulo anterior. En este capítulo, sin embargo, se calcula la quiralidad de la estructura y los fonones usando el CCM como criterio.

Debajo, se definen varias constantes a emplear. Dentro de estas están las masas de los sitios, la longitud de los lados del ángulo vista desde arriba, las constantes de resorte y el ángulo de los enlaces respecto al plano x - y. Además, se definen las posiciones los tres átomos dentro de la celda unitaria, y dos átomos de celdas vecinas. 

```{python}
# Masas de los distintos sitios. 
m1 = 1
m2 = 1
m3 = 1

M = [m1,m2,m3]

# Matriz de resortes a lo largo de x.
KL = 1
KT1 = 0.05
KT2 = 0.25

# Tensor de constante de red en configuración usual. 
Kx = array([[KL,0,0],
              [0,KT1,0],
              [0,0,KT2]],dtype=complex)

# Longitud de los enlaces proyectados al plano
a = 1

# Ángulo de los enlaces respecto al plano x - y.
φxy = pi/3

# Longitud de la celda unitaria.
c = 3 * a * tan(φxy)

# Posiciones de los átomos en la celda unitaria de la cadena.
r1 = array([1,0,0])
r2 = array([-1/2, sqrt(3)/2,c/3])
r3 = array([-1/2, -sqrt(3)/2,2*c/3])

# Posición de los átomos en la celda vecina. 
r1plus = r1 + [0,0,c]
r3minus = r3 - [0,0,c]

positions = array([r1,r2,r3])

positionsnn = array([r3minus,r1plus])

X,Y,Z = positions.T
Xnn,Ynn,Znn = positionsnn.T
```

Debajo, se muestra una imagen de la cadena. 

```{python}
DATA = [go.Scatter3d(x=X, y=Y, z=Z,mode='markers',marker_color = "blue",showlegend=False)]

DATA.append(go.Scatter3d(x=Xnn, y=Ynn, z=Znn,mode='markers',marker_color = "red",showlegend=False))

DATA.append(go.Scatter3d(x= [X[0],Xnn[0]], y=[Y[0],Ynn[0]], z=[Z[0],Znn[0]],mode='lines',line=dict(color='red'),showlegend=False))

DATA.append(go.Scatter3d(x= [X[0],X[1]], y=[Y[0],Y[1]], z=[Z[0],Z[1]],mode='lines',line=dict(color='blue'),showlegend=False))

DATA.append(go.Scatter3d(x= [X[2],X[1]], y=[Y[2],Y[1]], z=[Z[2],Z[1]],mode='lines',line=dict(color='blue'),showlegend=False))

DATA.append(go.Scatter3d(x= [X[2],Xnn[1]], y=[Y[2],Ynn[1]], z=[Z[2],Znn[1]],mode='lines',line=dict(color='red'),showlegend=False))
```

```{python}
fig = go.Figure(data=DATA)
fig.show()
```

## Cálculo de CCM de la estructura

Para calcular el CCM de la estructura se sigue la definición del capítulo pasado. Sin embargo, para hacer este cálculo sólo se consideran reflexiones por planos que contengan al eje z. Esto pues sólo nos interesa la quiralidad respecto a este eje. Aún así, se define una rotación respecto al plano x - y que será utilizada más adelante en el cálculo de la matriz dinámica. 

```{python}
#Rotación de φ respecto al plano x - y.
def T(φ):
  return array([[cos(φ) ,0.  ,sin(φ)],
                [0.     ,1.  ,0],
                [-sin(φ),0.  ,cos(φ)]])

                #Rotación respecto al eje z.
def U(θ):
  return array([[cos(θ),-sin(θ),0],
              [sin(θ),cos(θ),0],
              [       0,      0,1]] )
```

También se definen la matriz identidad en 3D y una reflexión respecto al plano xz. Además, se define una funciín que transforma operadores. Esta función se usará para rotar el plano respecto al cual se realiza la rotación. 

```{python}

#Matriz identidad.
Id = array([[1,0,0],
            [0,1,0],
            [0,0,1]] )

#Reflexión respecto al plano x - z.
σy = array([[-1,0,0],
            [0,1,0],
            [0,0,1]] )

def TensT(O,A):
  """Función que aplica transforma por un operador O a un tensor A."""
  return dot( inv(O), dot(A,O) )
```

Ya con todas las funciones a usar bien definidas, se hace el cálculo de la CCM De la estructura. Para ello, primero se calculan las coordenadas respecto al centro de masa. 

```{python}
# Centro de masa
RCM = (m1*r1 + m2*r2 + m3*r3)/(m1 + m2 + m3)

# Coordenada Relativa 1
qrcm1 = sqrt(m1)*(r1 - RCM)

# Coordenada Relativa 2
qrcm2 = sqrt(m2)*(r2 - RCM)

# Coordenada Relativa 3
qrcm3 = sqrt(m3)*(r3 - RCM)

# Lista con las coordenadas relativas. 
Qrcm = [qrcm1,qrcm2,qrcm3]
```

Queremos calcular la CCM tal que el plano de inversión elegido maximize la superposición de la estructura con la estructura invertida. Para ello, se define una función que calcula el CCM de la estructura tomando una reflexión respecto a un plano de entrada. 
```{python}
def CCMS(σ):
    num = 0
    den = 0
    for q in Qrcm:
        num = num + dot(q,dot(Id + σ,q))
        den = den + dot(q,q)
    return 1 - (num/(2*den))
```

Ya hecho esto, se calcula el CCM de la estructura. Notamos que para esta cadena el CCM es igual sin importar que plano de reflexión se use. Esto se ve en la gráfica mostrada debajo. 

```{python}
θ = linspace(0,pi,300)

σ = []

for ang in θ:
    σ.append(TensT(U(ang),σy))
σ = array(σ)

CCM_estructura = []

for ref in σ:
    CCM_estructura.append(CCMS(ref))

print("La CCM de la estructura es", str(np.min(CCM_estructura)))
```

```{python}
Labels = [r"0",r"π/2",r"π"]
Ticks = concatenate([[0],[pi/2],[pi]])

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(6,4.5))
ax.plot(θ,CCM_estructura)
ax.set_xticks(Ticks)
ax.set_ylim([0,1])
ax.set_xticklabels(Labels,fontsize = 20);
ax.set_ylabel("CCM",fontsize = 20)
plt.show()
```

## Cálculos del CCM de los modos vibracionales

Ahora calculamos el CCM asociado a los modos normales. Para ello, debemos también construir un programa que obtenga las frecuencias de dichos modos, así como una función que de el CCM de un modo dado.

Primero, se define una función que regresa el valor máximo del producto $\langle Q| Q \rangle$ para cierto plano de reflexión. Además, se define una función que regresa el valor esperado y que será usada más adelante. 

```{python}
def expectedval(vec,S):
    return dot(np.conj(vec).T,dot(S,vec)).real

θ = linspace(0,pi,300)

def CCMMax(q):
    max = 0
    for ang in θ:
        σ = TensT(U(ang),σy)
        if abs(expectedval(q,Id + σ)) > max:
            max = abs(expectedval(q,Id + σ))
            M = expectedval(q,Id + σ)
    return M
```

Luego, se define la función que calcula las frecuencias de un modo normal para un punto del espacio recíproco dado. 

```{python}
def EigenfrequenciesC3(k):

  """Función que regresa las eigenfrecuencias para un vector recíproco kz dado."""

  #Se define el tensor de esfuerzos de todo el sistema.

  #Matriz con constante de fuerza considerando una rotación respecto al plano x - y.
  φxy = pi/3
  Kx2 = dot(T(φxy),dot(Kx,T(-φxy)))

  #Matrices de fuerza para cada uno de los vectores en la red.
  K23 = dot(U(pi),dot(Kx2,U(-pi)))     #Calculada tomando 2 como origen.
  K12 = dot(U(pi/3),dot(Kx2,U(-pi/3))) #Calculada tomando 1 como origen.
  K13 = dot(U(-pi/3),dot(Kx2,U(pi/3))) #Calculado tomando 3 como origen.

  DicMat   = { 0: (K12 + K13)/m1,
               1: -K12/sqrt(m1*m2),
               2: -K13/sqrt(m1*m3)*exp(-1J*k*c),
               3: -K12/sqrt(m1*m2),
               4: (K23+K12)/m2,
               5: -K23/sqrt(m2*m3),
               6: -K13/sqrt(m1*m3)*exp(1J*k*c),
               7: -K23/sqrt(m2*m3),
               8: (K23 + K13)/m3 }

  Dinteger = array([[0,1,2],
                    [3,4,5],
                    [6,7,8]])

  Dm = [ [DicMat[i] for i in rw] for rw in Dinteger ]
  Dynamical = asarray(np.bmat(Dm))

  ω2,eigvecs = eigh(Dynamical)

  return sqrt(abs(ω2))/2/pi,eigvecs
```

Se definió una función que calculaba el CCM dadas una frecuencia y un modo normal. 

```{python}
def CCM_general(ω,eigvecs):
  CCM = []
  for i in range(len(ω2)):
    eigvec = eigvecs[:,i]
    q1 = sqrt(m1) * eigvec[0:3]
    q2 = sqrt(m2) * eigvec[3:6]
    q3 = sqrt(m3) * eigvec[6:]

    Q = [q1,q2,q3]

    num = 0
    den = 0

    

    for q in Q:
        num += CCMMax(q)
        den += vdot(q,q).real

    CCM.append(1 - (num/(2*den)))

  return CCM
```

Finalmente, se muestra la gráfica de bandas para la cadena $C_{3}$ junto con los respectivos valores de CCM en cada punto:

```{python}
Kpoints = np.linspace(-pi/c,pi/c,500)

Klabels = [r"K/2",r"Γ",r"K/2"]
Kticks = concatenate([[0],[250],[500]])

BandasC3 = []
EigvecsC3 = []
CCMC3 = []

KevaluateC3 = (list( map(EigenfrequenciesC3,Kpoints) ))

for ω2,eigvec in KevaluateC3:
  BandasC3.append(ω2)
  EigvecsC3.append(eigvec)

for i in range(len(BandasC3)):
  CCMC3.append(CCM_general(BandasC3[i],EigvecsC3[i]))

CCMC3 = array(CCMC3)
BandasC3 = array(BandasC3)
```

```{python}
numKC3,nbandsC3 = shape(BandasC3)
kenumC3 = arange(numKC3)

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))
for j in range(nbandsC3):
  graficaC3 = ax.scatter(kenumC3,BandasC3.T[j],c = CCMC3.T[j],cmap = "Reds",vmax = 1, vmin = 0,s = 5)
fig.colorbar(graficaC3)
ax.set_xticks(Kticks)
ax.set_xticklabels(Klabels,fontsize = 20);
```

Ahora, hacemos el estudio de quiralidad mediante el cálculo del Pseudomomento escalar. Dado un modo $k$, este está determinado por $$(\sum p^{z}L^{z})_{k} = -(\omega_{k})^{2}\left[\sum_{i}m_{i}c^{z}_{ki}\left(x_{i}c^{y}_{k,i} - y_{i}c^{x}_{k,i}\right)\right].$$ Debajo, se define una función que calcula el valor del escalar de pseudomomento para cada valor de $k$.


```{python}
def EigenfrequenciesC3PM(k):

  """Función que regresa las eigenfrecuencias para un vector recíproco kz dado."""

  #Se define el tensor de esfuerzos de todo el sistema.

  #Matriz con constante de fuerza considerando una rotación respecto al plano x - y.
  φxy = pi/3
  Kx2 = dot(T(φxy),dot(Kx,T(-φxy)))

  #Matrices de fuerza para cada uno de los vectores en la red.
  K23 = dot(U(pi),dot(Kx2,U(-pi)))     #Calculada tomando 2 como origen.
  K12 = dot(U(pi/3),dot(Kx2,U(-pi/3))) #Calculada tomando 1 como origen.
  K13 = dot(U(-pi/3),dot(Kx2,U(pi/3))) #Calculado tomando 3 como origen.

  DicMat   = { 0: (K12 + K13)/m1,
               1: -K12/sqrt(m1*m2),
               2: -K13/sqrt(m1*m3)*exp(-1J*k*c),
               3: -K12/sqrt(m1*m2),
               4: (K23+K12)/m2,
               5: -K23/sqrt(m2*m3),
               6: -K13/sqrt(m1*m3)*exp(1J*k*c),
               7: -K23/sqrt(m2*m3),
               8: (K23 + K13)/m3 }

  Dinteger = array([[0,1,2],
                    [3,4,5],
                    [6,7,8]])

  Dm = [ [DicMat[i] for i in rw] for rw in Dinteger ]
  Dynamical = asarray(np.bmat(Dm))

  ω2,eigvecs = eigh(Dynamical)

  PM = []
    
  for i in range(len(ω2)):
    eigvec = eigvecs[:,i]
    ω = sqrt(abs(ω2[i]))/2/pi
    q1 = sqrt(m1) * eigvec[0:3]
    q2 = sqrt(m2) * eigvec[3:6]
    q3 = sqrt(m3) * eigvec[6:]

    Q = [q1,q2,q3]

    pz = 0

    for i in range(3):
        pz = pz + M[i]*Q[i][2]*(X[i]*Q[i][1] - Y[i]*Q[i][0]).real
    PM.append(pz)

  return sqrt(abs(ω2))/2/pi,PM
```

Definimos una función que recibe como entrada los modos normales de una una función y regresa el valor de CCM para cada modo.

```{python}
Kpoints = np.linspace(-pi/c,pi/c,500)

Klabels = [r"K/2",r"Γ",r"K/2"]
Kticks = concatenate([[0],[250],[500]])

BandasC3 = []
PseudomomC3 = []

KevaluateC3 = (list( map(EigenfrequenciesC3PM,Kpoints) ))

for ω2,psmom in KevaluateC3:
  BandasC3.append(ω2)
  PseudomomC3.append(psmom)

BandasC3 = array(BandasC3)
PseudomomC3 = array(PseudomomC3)

numKC3,nbandsC3 = shape(BandasC3)
kenumC3 = arange(numKC3)

fig,ax = plt.subplots(ncols=1,nrows=1,figsize=(4.5,6))
for j in range(nbandsC3):
  graficaC3 = ax.scatter(kenumC3,BandasC3.T[j],c = PseudomomC3.T[j],cmap = "coolwarm",vmax = 0.1, vmin = -0.1,s = 5)
fig.colorbar(graficaC3)
ax.set_xticks(Kticks)
ax.set_xticklabels(Klabels,fontsize = 20);
```
